<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Goga &ndash; Documentation</title>
<link type="text/css" rel="stylesheet" href="static/style.css">
<script type="text/javascript" src="static/godocs.js"></script>
<style type="text/css"></style>
</head>
<body>
<div id="page">
<h1>Goga &ndash; Documentation</h1>
<h2 id="pkg-index">Index</h2>
<div id="manual-nav">
<dl>
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = ;
	document.CALLGRAPH = ;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/cpmech/goga"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				
			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#BytCrossover">func BytCrossover(a, b, A, B [][]byte, time int, ops *OpsData) (ends []int)</a></dd>
			
				
				<dd><a href="#BytMutation">func BytMutation(A [][]byte, time int, ops *OpsData)</a></dd>
			
				
				<dd><a href="#FilterPairs">func FilterPairs(A, B []int, selinds []int)</a></dd>
			
				
				<dd><a href="#FltCrossover">func FltCrossover(a, b, A, B []float64, time int, ops *OpsData) (ends []int)</a></dd>
			
				
				<dd><a href="#FltCrossoverBlx">func FltCrossoverBlx(a, b, A, B []float64, time int, ops *OpsData) (ends []int)</a></dd>
			
				
				<dd><a href="#FltMutation">func FltMutation(A []float64, time int, ops *OpsData)</a></dd>
			
				
				<dd><a href="#FltMutationMwicz">func FltMutationMwicz(A []float64, time int, ops *OpsData)</a></dd>
			
				
				<dd><a href="#FunCrossover">func FunCrossover(a, b, A, B []Func_t, time int, ops *OpsData) (ends []int)</a></dd>
			
				
				<dd><a href="#FunMutation">func FunMutation(A []Func_t, time int, ops *OpsData)</a></dd>
			
				
				<dd><a href="#GenerateCxEnds">func GenerateCxEnds(size, ncuts int, cuts []int) (ends []int)</a></dd>
			
				
				<dd><a href="#IndCompareDet">func IndCompareDet(A, B *Individual) (A_dominates, B_dominates bool)</a></dd>
			
				
				<dd><a href="#IndCompareProb">func IndCompareProb(A, B *Individual, φ float64) (A_dominates bool)</a></dd>
			
				
				<dd><a href="#IndCrossover">func IndCrossover(a, b, A, B *Individual, time int, ops *OpsData)</a></dd>
			
				
				<dd><a href="#IndDistance">func IndDistance(A, B *Individual) (dist float64)</a></dd>
			
				
				<dd><a href="#IndMutation">func IndMutation(A *Individual, time int, ops *OpsData)</a></dd>
			
				
				<dd><a href="#IntBinMutation">func IntBinMutation(A []int, time int, ops *OpsData)</a></dd>
			
				
				<dd><a href="#IntCrossover">func IntCrossover(a, b, A, B []int, time int, ops *OpsData) (ends []int)</a></dd>
			
				
				<dd><a href="#IntMutation">func IntMutation(A []int, time int, ops *OpsData)</a></dd>
			
				
				<dd><a href="#IntOrdCrossover">func IntOrdCrossover(a, b, A, B []int, time int, ops *OpsData) (notused []int)</a></dd>
			
				
				<dd><a href="#IntOrdMutation">func IntOrdMutation(A []int, time int, ops *OpsData)</a></dd>
			
				
				<dd><a href="#KeyCrossover">func KeyCrossover(a, b, A, B []byte, time int, ops *OpsData) (ends []int)</a></dd>
			
				
				<dd><a href="#KeyMutation">func KeyMutation(A []byte, time int, ops *OpsData)</a></dd>
			
				
				<dd><a href="#PlotOor">func PlotOor(isl *Island, ext, args string, t0, tf int, first, last bool)</a></dd>
			
				
				<dd><a href="#PlotOvs">func PlotOvs(isl *Island, ext, args string, t0, tf int, first, last bool)</a></dd>
			
				
				<dd><a href="#PlotTwoVarsContour">func PlotTwoVarsContour(dirout, fnkey string, pop0, pop1 Population, best *Individual, np int, extra func(), axequal bool, vmin, vmax []float64, istrans, tplot bool, T, Ti TwoVarsTrans_t, f TwoVarsFunc_t, gs ...TwoVarsFunc_t)</a></dd>
			
				
				<dd><a href="#RouletteSelect">func RouletteSelect(selinds []int, cumprob []float64, sample []float64)</a></dd>
			
				
				<dd><a href="#SUSselect">func SUSselect(selinds []int, cumprob []float64, pb float64)</a></dd>
			
				
				<dd><a href="#SimpleChromo">func SimpleChromo(genes []float64, nbases int) (chromo []float64)</a></dd>
			
				
				<dd><a href="#StrCrossover">func StrCrossover(a, b, A, B []string, time int, ops *OpsData) (ends []int)</a></dd>
			
				
				<dd><a href="#StrMutation">func StrMutation(A []string, time int, ops *OpsData)</a></dd>
			
			
				
				<dd><a href="#ConfParams">type ConfParams</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewConfParams">func NewConfParams() *ConfParams</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ReadConfParams">func ReadConfParams(filenamepath string) *ConfParams</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ConfParams.CalcDerived">func (o *ConfParams) CalcDerived()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ConfParams.SetDefault">func (o *ConfParams) SetDefault()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ConfParams.SetIntBin">func (o *ConfParams) SetIntBin(size int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ConfParams.SetIntOrd">func (o *ConfParams) SetIntOrd(nstations int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ConfParams.SetNbasesFixOp">func (o *ConfParams) SetNbasesFixOp(nbases int)</a></dd>
				
			
				
				<dd><a href="#CxBytFunc_t">type CxBytFunc_t</a></dd>
				
				
			
				
				<dd><a href="#CxFltFunc_t">type CxFltFunc_t</a></dd>
				
				
			
				
				<dd><a href="#CxFunFunc_t">type CxFunFunc_t</a></dd>
				
				
			
				
				<dd><a href="#CxIntFunc_t">type CxIntFunc_t</a></dd>
				
				
			
				
				<dd><a href="#CxKeyFunc_t">type CxKeyFunc_t</a></dd>
				
				
			
				
				<dd><a href="#CxStrFunc_t">type CxStrFunc_t</a></dd>
				
				
			
				
				<dd><a href="#Evolver">type Evolver</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewEvolver">func NewEvolver(nova, noor int, C *ConfParams) (o *Evolver)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Evolver.FindBestFromAll">func (o *Evolver) FindBestFromAll()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Evolver.GetFeasible">func (o *Evolver) GetFeasible() (feasible []*Individual)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Evolver.GetFrontOvas">func (o *Evolver) GetFrontOvas(r, s int, front []*Individual) (x, y []float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Evolver.GetParetoFront">func (o *Evolver) GetParetoFront(feasible []*Individual, ovas, oors [][]float64) (ovafront, oorfront []*Individual)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Evolver.GetResults">func (o *Evolver) GetResults(subset []*Individual) (ovas, oors [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Evolver.Run">func (o *Evolver) Run()</a></dd>
				
			
				
				<dd><a href="#Func_t">type Func_t</a></dd>
				
				
			
				
				<dd><a href="#Individual">type Individual</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewIndividual">func NewIndividual(nova, noor, nbases int, slices ...interface{}) (o *Individual)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Individual.CopyInto">func (o Individual) CopyInto(x *Individual)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Individual.GetCopy">func (o Individual) GetCopy() (x *Individual)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Individual.GetFloat">func (o Individual) GetFloat(igene int) (x float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Individual.GetFloats">func (o Individual) GetFloats() (x []float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Individual.GetStringSizes">func (o *Individual) GetStringSizes() (sizes [][]int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Individual.Output">func (o *Individual) Output(fmts [][]string, showBases bool) (l string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Individual.SetFloat">func (o *Individual) SetFloat(igene int, x float64)</a></dd>
				
			
				
				<dd><a href="#Island">type Island</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewIsland">func NewIsland(id, nova, noor int, C *ConfParams) (o *Island)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Island.CalcDemeritsAndSort">func (o *Island) CalcDemeritsAndSort(pop Population)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Island.CalcOvs">func (o *Island) CalcOvs(pop Population, time int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Island.FltStat">func (o *Island) FltStat() (minrho, averho, maxrho, devrho float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Island.Regenerate">func (o *Island) Regenerate(time int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Island.Run">func (o *Island) Run(time int, doreport, verbose bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Island.SaveReport">func (o Island) SaveReport(verbose bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Island.WritePopToReport">func (o *Island) WritePopToReport(time int, averho float64)</a></dd>
				
			
				
				<dd><a href="#MtBytFunc_t">type MtBytFunc_t</a></dd>
				
				
			
				
				<dd><a href="#MtFltFunc_t">type MtFltFunc_t</a></dd>
				
				
			
				
				<dd><a href="#MtFunFunc_t">type MtFunFunc_t</a></dd>
				
				
			
				
				<dd><a href="#MtIntFunc_t">type MtIntFunc_t</a></dd>
				
				
			
				
				<dd><a href="#MtKeyFunc_t">type MtKeyFunc_t</a></dd>
				
				
			
				
				<dd><a href="#MtStrFunc_t">type MtStrFunc_t</a></dd>
				
				
			
				
				<dd><a href="#Objectives_t">type Objectives_t</a></dd>
				
				
			
				
				<dd><a href="#OpsData">type OpsData</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#OpsData.CalcDerived">func (o *OpsData) CalcDerived(Tf int, xrange [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#OpsData.EnforceRange">func (o *OpsData) EnforceRange(igene int, x float64) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#OpsData.MwiczDelta">func (o *OpsData) MwiczDelta(t, x float64) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#OpsData.SetDefault">func (o *OpsData) SetDefault()</a></dd>
				
			
				
				<dd><a href="#PopBytGen_t">type PopBytGen_t</a></dd>
				
				
			
				
				<dd><a href="#PopFltGen_t">type PopFltGen_t</a></dd>
				
				
			
				
				<dd><a href="#PopFunGen_t">type PopFunGen_t</a></dd>
				
				
			
				
				<dd><a href="#PopIntGen_t">type PopIntGen_t</a></dd>
				
				
			
				
				<dd><a href="#PopKeyGen_t">type PopKeyGen_t</a></dd>
				
				
			
				
				<dd><a href="#PopStrGen_t">type PopStrGen_t</a></dd>
				
				
			
				
				<dd><a href="#Population">type Population</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PopBinGen">func PopBinGen(ninds, nova, noor, nbases int, noise float64, nints int, unused [][]int) Population</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PopFltGen">func PopFltGen(ninds, nova, noor, nbases int, noise float64, frange [][]float64) Population</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PopOrdGen">func PopOrdGen(ninds, nova, noor, nbases int, noise float64, nints int, unused [][]int) Population</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Population.GetCopy">func (o Population) GetCopy() (pop Population)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Population.Len">func (o Population) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Population.Less">func (o Population) Less(i, j int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Population.OutFloatBases">func (o Population) OutFloatBases(numFmt string) (l string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Population.Output">func (o Population) Output(fmts [][]string, showOor, showBases bool, showNinds int) (buf *bytes.Buffer)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Population.Sort">func (o *Population) Sort()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Population.Swap">func (o Population) Swap(i, j int)</a></dd>
				
			
				
				<dd><a href="#PostProc_t">type PostProc_t</a></dd>
				
				
			
				
				<dd><a href="#TwoVarsFunc_t">type TwoVarsFunc_t</a></dd>
				
				
			
				
				<dd><a href="#TwoVarsTrans_t">type TwoVarsTrans_t</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/github.com/cpmech/goga/definitions.go">definitions.go</a>
			
				<a href="/src/github.com/cpmech/goga/evolver.go">evolver.go</a>
			
				<a href="/src/github.com/cpmech/goga/individual.go">individual.go</a>
			
				<a href="/src/github.com/cpmech/goga/island.go">island.go</a>
			
				<a href="/src/github.com/cpmech/goga/operators.go">operators.go</a>
			
				<a href="/src/github.com/cpmech/goga/params.go">params.go</a>
			
				<a href="/src/github.com/cpmech/goga/plotting.go">plotting.go</a>
			
				<a href="/src/github.com/cpmech/goga/population.go">population.go</a>
			
				<a href="/src/github.com/cpmech/goga/selection.go">selection.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
		
		
			
			
			<h2 id="BytCrossover">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=12133:12208#L453">BytCrossover</a></h2>
			<pre>func BytCrossover(a, b, A, B [][]<a href="/pkg/builtin/#byte">byte</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>) (ends []<a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
BytCrossover performs the crossover of genetic data from A and B
</p>
<pre>Output:
 a and b -- offspring
Example:
       0 1 2 3 4 5 6 7
   A = a b c d e f g h    size = 8
   B = * . . . . * * *    cuts = [1, 5]
        ↑       ↑     ↑   ends = [1, 5, 8]
        1       5     8
   a = a . . . . f g h
   b = * b c d e * * *
</pre>

			
			

		
			
			
			<h2 id="BytMutation">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=18147:18199#L699">BytMutation</a></h2>
			<pre>func BytMutation(A [][]<a href="/pkg/builtin/#byte">byte</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>)</pre>
			<p>
BytMutation performs the mutation of genetic data from A
</p>
<pre>Output: modified individual &#39;A&#39;
</pre>

			
			

		
			
			
			<h2 id="FilterPairs">func <a href="https://github.com/cpmech/goga/blob/master//selection.go?s=1979:2022#L68">FilterPairs</a></h2>
			<pre>func FilterPairs(A, B []<a href="/pkg/builtin/#int">int</a>, selinds []<a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
FilterPairs generates 2 lists with ninds/2 items each corresponding to selected pairs
for reprodoction. Repeated indices in pairs are avoided.
</p>
<pre>Input:
 selinds -- list of selected individuals len(selinds) == ninds
Output:
 A and B -- [ninds/2] lists with pairs
</pre>

			
			

		
			
			
			<h2 id="FltCrossover">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=8783:8859#L313">FltCrossover</a></h2>
			<pre>func FltCrossover(a, b, A, B []<a href="/pkg/builtin/#float64">float64</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>) (ends []<a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
FltCrossover performs the crossover of genetic data from A and B
</p>
<pre>Output:
 a and b -- offspring
Example:
       0 1 2 3 4 5 6 7
   A = a b c d e f g h    size = 8
   B = * . . . . * * *    cuts = [1, 5]
        ↑       ↑     ↑   ends = [1, 5, 8]
        1       5     8
   a = a . . . . f g h
   b = * b c d e * * *
</pre>

			
			

		
			
			
			<h2 id="FltCrossoverBlx">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=9442:9521#L343">FltCrossoverBlx</a></h2>
			<pre>func FltCrossoverBlx(a, b, A, B []<a href="/pkg/builtin/#float64">float64</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>) (ends []<a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
FltCrossoverBlx implements the BLS-α crossover by Eshelman et al. (1993); see also Herrera (1998)
</p>
<pre>Output:
 a and b -- offspring
</pre>

			
			

		
			
			
			<h2 id="FltMutation">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=16474:16527#L633">FltMutation</a></h2>
			<pre>func FltMutation(A []<a href="/pkg/builtin/#float64">float64</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>)</pre>
			<p>
FltMutation performs the mutation of genetic data from A
</p>
<pre>Output: modified individual &#39;A&#39;
</pre>

			
			

		
			
			
			<h2 id="FltMutationMwicz">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=16922:16980#L651">FltMutationMwicz</a></h2>
			<pre>func FltMutationMwicz(A []<a href="/pkg/builtin/#float64">float64</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>)</pre>
			<p>
FltMutationMwicz implements the non-uniform mutation (Michaelewicz, 1992; Herrera, 1998)
See also Michalewicz (1996) page 103
</p>

			
			

		
			
			
			<h2 id="FunCrossover">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=13056:13131#L494">FunCrossover</a></h2>
			<pre>func FunCrossover(a, b, A, B []<a href="#Func_t">Func_t</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>) (ends []<a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
FunCrossover performs the crossover of genetic data from A and B
</p>
<pre>Output:
 a and b -- offspring
Example:
       0 1 2 3 4 5 6 7
   A = a b c d e f g h    size = 8
   B = * . . . . * * *    cuts = [1, 5]
        ↑       ↑     ↑   ends = [1, 5, 8]
        1       5     8
   a = a . . . . f g h
   b = * b c d e * * *
</pre>

			
			

		
			
			
			<h2 id="FunMutation">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=18511:18563#L713">FunMutation</a></h2>
			<pre>func FunMutation(A []<a href="#Func_t">Func_t</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>)</pre>
			<p>
FunMutation performs the mutation of genetic data from A
</p>
<pre>Output: modified individual &#39;A&#39;
</pre>

			
			

		
			
			
			<h2 id="GenerateCxEnds">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=4204:4265#L139">GenerateCxEnds</a></h2>
			<pre>func GenerateCxEnds(size, ncuts <a href="/pkg/builtin/#int">int</a>, cuts []<a href="/pkg/builtin/#int">int</a>) (ends []<a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
GenerateCxEnds randomly computes the end positions of cuts in chromosomes
</p>
<pre>Input:
 size  -- size of chromosome
 ncuts -- number of cuts to be used, unless cuts != nil
 cuts  -- cut positions. can be nil =&gt; use ncuts instead
Output:
 ends -- end positions where the last one equals size
Example:
      0 1 2 3 4 5 6 7
  A = a b c d e f g h    size = 8
       ↑       ↑     ↑   cuts = [1, 5]
       1       5     8   ends = [1, 5, 8]
</pre>

			
			

		
			
			
			<h2 id="IndCompareDet">func <a href="https://github.com/cpmech/goga/blob/master//individual.go?s=3830:3898#L160">IndCompareDet</a></h2>
			<pre>func IndCompareDet(A, B *<a href="#Individual">Individual</a>) (A_dominates, B_dominates <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
IndCompareDet compares individual &#39;A&#39; with another one &#39;B&#39;. Deterministic method
</p>

			
			

		
			
			
			<h2 id="IndCompareProb">func <a href="https://github.com/cpmech/goga/blob/master//individual.go?s=4466:4534#L187">IndCompareProb</a></h2>
			<pre>func IndCompareProb(A, B *<a href="#Individual">Individual</a>, φ <a href="/pkg/builtin/#float64">float64</a>) (A_dominates <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
IndCompareProb compares individual &#39;A&#39; with another one &#39;B&#39; using probabilistic Pareto method
</p>

			
			

		
			
			
			<h2 id="IndCrossover">func <a href="https://github.com/cpmech/goga/blob/master//individual.go?s=5710:5775#L234">IndCrossover</a></h2>
			<pre>func IndCrossover(a, b, A, B *<a href="#Individual">Individual</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>)</pre>
			<p>
IndCrossover performs the crossover between chromosomes of two individuals A and B
resulting in the chromosomes of other two individuals a and b
</p>

			
			

		
			
			
			<h2 id="IndDistance">func <a href="https://github.com/cpmech/goga/blob/master//individual.go?s=5051:5100#L210">IndDistance</a></h2>
			<pre>func IndDistance(A, B *<a href="#Individual">Individual</a>) (dist <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
IndDistance computes a distance measure from individual &#39;A&#39; to another individual &#39;B&#39;
</p>

			
			

		
			
			
			<h2 id="IndMutation">func <a href="https://github.com/cpmech/goga/blob/master//individual.go?s=6367:6422#L256">IndMutation</a></h2>
			<pre>func IndMutation(A *<a href="#Individual">Individual</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>)</pre>
			<p>
IndMutation performs the mutation operation in the chromosomes of an individual
</p>

			
			

		
			
			
			<h2 id="IntBinMutation">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=14184:14236#L543">IntBinMutation</a></h2>
			<pre>func IntBinMutation(A []<a href="/pkg/builtin/#int">int</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>)</pre>
			<p>
IntBinMutation performs the mutation of a binary chromosome
</p>
<pre>Output: modified individual &#39;A&#39;
</pre>

			
			

		
			
			
			<h2 id="IntCrossover">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=5570:5642#L201">IntCrossover</a></h2>
			<pre>func IntCrossover(a, b, A, B []<a href="/pkg/builtin/#int">int</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>) (ends []<a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
IntCrossover performs the crossover of genetic data from A and B
</p>
<pre>Output:
 a and b -- offspring
Example:
       0 1 2 3 4 5 6 7
   A = a b c d e f g h    size = 8
   B = * . . . . * * *    cuts = [1, 5]
        ↑       ↑     ↑   ends = [1, 5, 8]
        1       5     8
   a = a . . . . f g h
   b = * b c d e * * *
</pre>

			
			

		
			
			
			<h2 id="IntMutation">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=13772:13821#L525">IntMutation</a></h2>
			<pre>func IntMutation(A []<a href="/pkg/builtin/#int">int</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>)</pre>
			<p>
IntMutation performs the mutation of genetic data from A
</p>
<pre>Output: modified individual &#39;A&#39;
</pre>

			
			

		
			
			
			<h2 id="IntOrdCrossover">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=7484:7562#L254">IntOrdCrossover</a></h2>
			<pre>func IntOrdCrossover(a, b, A, B []<a href="/pkg/builtin/#int">int</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>) (notused []<a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
IntOrdCrossover performs the crossover in a pair of individuals with integer numbers
that correspond to a ordered sequence, e.g. for traveling salesman problem
</p>
<pre>Output:
  a and b -- offspring chromosomes
Note: using OX1 method explained in [1] (proposed in [2])
References:
 [1] Larrañaga P, Kuijpers CMH, Murga RH, Inza I and Dizdarevic S. Genetic Algorithms for the
     Travelling Salesman Problem: A Review of Representations and Operators. Artificial
     Intelligence Review, 13:129-170; 1999. doi:10.1023/A:1006529012972
 [2] Davis L. Applying Adaptive Algorithms to Epistatic Domains. Proceedings of International
     Joint Conference on Artificial Intelligence, 162-164; 1985.
Example:
 data:
       0 1   2 3 4   5 6 7
   A = a b | c d e | f g h        size = 8
   B = b d | f h g | e c a        cuts = [2, 5]
           ↑       ↑       ↑      ends = [2, 5, 8]
           2       5       8
 first step: copy subtours
   a = . . | f h g | . . .
   b = . . | c d e | . . .
 second step: copy unique from subtour&#39;s end, position 5
             start adding here
                     ↓                           5 6 7   0 1   2 3 4
   a = d e | f h g | a b c         get from A: | f̶ g̶ h̶ | a b | c d e
   b = h g | c d e | a b f         get from B: | e̶ c̶ a | b d̶ | f h g
</pre>

			
			

		
			
			
			<h2 id="IntOrdMutation">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=15523:15575#L582">IntOrdMutation</a></h2>
			<pre>func IntOrdMutation(A []<a href="/pkg/builtin/#int">int</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>)</pre>
			<p>
IntOrdMutation performs the mutation of genetic data from a ordered list of integers A
</p>
<pre>Output: modified individual &#39;A&#39;
Note: using DM method as explained in [1] (citing [2])
References:
 [1] Larrañaga P, Kuijpers CMH, Murga RH, Inza I and Dizdarevic S. Genetic Algorithms for the
     Travelling Salesman Problem: A Review of Representations and Operators. Artificial
     Intelligence Review, 13:129-170; 1999. doi:10.1023/A:1006529012972
 [2] Michalewicz Z. Genetic Algorithms + Data Structures = Evolution Programs. Berlin
     Heidelberg: Springer Verlag; 1992
     Joint Conference on Artificial Intelligence, 162-164; 1985.

DM displacement mutation method:
 Ex:
         0 1 2 3 4 5 6 7
     A = a b c d e f g h   s = 2
            ↑     ↑        t = 5
            2     5

     core = c d e  (subtour)  ncore = t - s = 5 - 2 = 3

              0 1 2 3 4
     remain = a b f g h  (remaining)  nrem = size - ncore = 8 - 3 = 5
                     ↑
                     4 = ins
</pre>

			
			

		
			
			
			<h2 id="KeyCrossover">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=11253:11326#L415">KeyCrossover</a></h2>
			<pre>func KeyCrossover(a, b, A, B []<a href="/pkg/builtin/#byte">byte</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>) (ends []<a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
KeyCrossover performs the crossover of genetic data from A and B
</p>
<pre>Output:
 a and b -- offspring
Example:
       0 1 2 3 4 5 6 7
   A = a b c d e f g h    size = 8
   B = * . . . . * * *    cuts = [1, 5]
        ↑       ↑     ↑   ends = [1, 5, 8]
        1       5     8
   a = a . . . . f g h
   b = * b c d e * * *
</pre>

			
			

		
			
			
			<h2 id="KeyMutation">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=17788:17838#L685">KeyMutation</a></h2>
			<pre>func KeyMutation(A []<a href="/pkg/builtin/#byte">byte</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>)</pre>
			<p>
KeyMutation performs the mutation of genetic data from A
</p>
<pre>Output: modified individual &#39;A&#39;
</pre>

			
			

		
			
			
			<h2 id="PlotOor">func <a href="https://github.com/cpmech/goga/blob/master//plotting.go?s=5914:5987#L204">PlotOor</a></h2>
			<pre>func PlotOor(isl *<a href="#Island">Island</a>, ext, args <a href="/pkg/builtin/#string">string</a>, t0, tf <a href="/pkg/builtin/#int">int</a>, first, last <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
PlotOor plots out-of-range values versus time
</p>

			
			

		
			
			
			<h2 id="PlotOvs">func <a href="https://github.com/cpmech/goga/blob/master//plotting.go?s=5251:5324#L179">PlotOvs</a></h2>
			<pre>func PlotOvs(isl *<a href="#Island">Island</a>, ext, args <a href="/pkg/builtin/#string">string</a>, t0, tf <a href="/pkg/builtin/#int">int</a>, first, last <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
PlotOvs plots objective values versus time
</p>

			
			

		
			
			
			<h2 id="PlotTwoVarsContour">func <a href="https://github.com/cpmech/goga/blob/master//plotting.go?s=1564:1790#L30">PlotTwoVarsContour</a></h2>
			<pre>func PlotTwoVarsContour(dirout, fnkey <a href="/pkg/builtin/#string">string</a>, pop0, pop1 <a href="#Population">Population</a>, best *<a href="#Individual">Individual</a>, np <a href="/pkg/builtin/#int">int</a>, extra func(), axequal <a href="/pkg/builtin/#bool">bool</a>,
    vmin, vmax []<a href="/pkg/builtin/#float64">float64</a>, istrans, tplot <a href="/pkg/builtin/#bool">bool</a>, T, Ti <a href="#TwoVarsTrans_t">TwoVarsTrans_t</a>, f <a href="#TwoVarsFunc_t">TwoVarsFunc_t</a>, gs ...<a href="#TwoVarsFunc_t">TwoVarsFunc_t</a>)</pre>
			<p>
PlotTwoVarsContour plots contour for two variables problem. len(x) == 2
</p>
<pre>Input:
 dirout  -- directory to save files
 fnkey   -- file name key for eps figure
 pop0    -- initial population. can be &lt;nil&gt; if individuals are not to be plotted
 pop1    -- final population. can be &lt;nil&gt; if individuals are not to be plotted
 best    -- best individual. can be &lt;nil&gt;
 np      -- number of points for contour
 extra   -- called just before saving figure
 axequal -- axis.equal
 vmin    -- min 0 values
 vmax    -- max 1 values
 istrans -- vmin, vmax and individuals are transformed y-values; otherwise they are x-values
 tplot   -- plot transformed plot; needs T and Ti.
 T       -- transformation: x → y
 Ti      -- transformation: y → x
 f       -- function to plot filled contour. can be &lt;nil&gt;
 gs      -- functions to plot contour @ level 0. can be &lt;nil&gt;
Note: g(x) operates on original x values
</pre>

			
			

		
			
			
			<h2 id="RouletteSelect">func <a href="https://github.com/cpmech/goga/blob/master//selection.go?s=524:595#L10">RouletteSelect</a></h2>
			<pre>func RouletteSelect(selinds []<a href="/pkg/builtin/#int">int</a>, cumprob []<a href="/pkg/builtin/#float64">float64</a>, sample []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
RouletteSelect selects n individuals
</p>
<pre>Input:
  cumprob -- cumulated probabilities (from sorted population)
  sample  -- a list of random numbers; can be nil
Output:
  selinds -- selected individuals (indices). len(selinds) == nsel
</pre>

			
			

		
			
			
			<h2 id="SUSselect">func <a href="https://github.com/cpmech/goga/blob/master//selection.go?s=1371:1431#L44">SUSselect</a></h2>
			<pre>func SUSselect(selinds []<a href="/pkg/builtin/#int">int</a>, cumprob []<a href="/pkg/builtin/#float64">float64</a>, pb <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SUSselect performs the Stochastic-Universal-Sampling selection
</p>
<pre>Input:
  cumprob -- cumulated probabilities (from sorted population)
  pb      -- one random number corresponding to the first probability (pointer/position)
             use pb = -1 to generate a random value here
Output:
  selinds -- selected individuals (indices)
</pre>

			
			

		
			
			
			<h2 id="SimpleChromo">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=3356:3421#L112">SimpleChromo</a></h2>
			<pre>func SimpleChromo(genes []<a href="/pkg/builtin/#float64">float64</a>, nbases <a href="/pkg/builtin/#int">int</a>) (chromo []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SimpleChromo splits &#39;genes&#39; into &#39;nbases&#39; unequal parts
</p>
<pre>Input:
  genes  -- a slice whose size equals to the number of genes
  nbases -- number of bases used to split &#39;genes&#39;
Output:
  chromo -- the chromosome

Example:

  genes = [0, 1, 2, ... nbases-1,  0, 1, 2, ... nbases-1]
           \___________________/   \___________________/
                  gene # 0               gene # 1
</pre>

			
			

		
			
			
			<h2 id="StrCrossover">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=10371:10446#L377">StrCrossover</a></h2>
			<pre>func StrCrossover(a, b, A, B []<a href="/pkg/builtin/#string">string</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>) (ends []<a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
StrCrossover performs the crossover of genetic data from A and B
</p>
<pre>Output:
 a and b -- offspring
Example:
       0 1 2 3 4 5 6 7
   A = a b c d e f g h    size = 8
   B = * . . . . * * *    cuts = [1, 5]
        ↑       ↑     ↑   ends = [1, 5, 8]
        1       5     8
   a = a . . . . f g h
   b = * b c d e * * *
</pre>

			
			

		
			
			
			<h2 id="StrMutation">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=17451:17503#L672">StrMutation</a></h2>
			<pre>func StrMutation(A []<a href="/pkg/builtin/#string">string</a>, time <a href="/pkg/builtin/#int">int</a>, ops *<a href="#OpsData">OpsData</a>)</pre>
			<p>
StrMutation performs the mutation of genetic data from A
</p>
<pre>Output: modified individual &#39;A&#39;
</pre>

			
			

		
		
			
			
			<h2 id="ConfParams">type <a href="https://github.com/cpmech/goga/blob/master//params.go?s=369:3902#L5">ConfParams</a></h2>
			<pre>type ConfParams struct {

    <span class="comment">// initialisation</span>
    Seed   <a href="/pkg/builtin/#int">int</a>     <span class="comment">// seed to initialise random numbers generator. Seed ≤ 0 means use current time</span>
    Pll    <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// allow running islands in parallel (go-routines)</span>
    Nisl   <a href="/pkg/builtin/#int">int</a>     <span class="comment">// number of islands</span>
    Ninds  <a href="/pkg/builtin/#int">int</a>     <span class="comment">// number of individuals: population size</span>
    Nbases <a href="/pkg/builtin/#int">int</a>     <span class="comment">// number of bases in chromosome</span>
    Grid   <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// generate individuals based on grid</span>
    Noise  <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// apply noise when generate based on grid (if Noise &gt; 0)</span>

    <span class="comment">// time control</span>
    Tf    <a href="/pkg/builtin/#int">int</a> <span class="comment">// number of generations</span>
    Dtout <a href="/pkg/builtin/#int">int</a> <span class="comment">// increment of time for output</span>
    Dtmig <a href="/pkg/builtin/#int">int</a> <span class="comment">// increment of time for migration</span>

    <span class="comment">// regeneration</span>
    RegTol    <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// tolerance for ρ to activate regeneration</span>
    RegPct    <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// percentage of individuals to be regenerated; e.g. 0.3</span>
    UseStdDev <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// use standard deviation (σ) instead of average deviation in Stat</span>

    <span class="comment">// operators&#39; data</span>
    Ops <a href="#OpsData">OpsData</a>

    <span class="comment">// selection and reproduction</span>
    Elite     <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// use elitism</span>
    Rws       <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// use Roulette-Wheel selection method</span>
    Rnk       <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// ranking</span>
    RnkSp     <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// selective pressure for ranking</span>
    GAtype    <a href="/pkg/builtin/#string">string</a>  <span class="comment">// type of GA; e.g. &#34;std&#34;, &#34;crowd&#34;, &#34;sharing&#34;</span>
    CrowdSize <a href="/pkg/builtin/#int">int</a>     <span class="comment">// crowd size</span>
    ParetoPhi <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// φ coefficient for probabilistic Pareto comparison</span>
    ShSize    <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// sharing sample size. percentage of Ninds; e.g. 0.1</span>
    ShAlp     <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// αshare</span>
    ShSig     <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// σshare</span>
    ShPhen    <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// use phenotype distance analysis in sharing; otherwise use objective values</span>

    <span class="comment">// output</span>
    Verbose   <a href="/pkg/builtin/#bool">bool</a>       <span class="comment">// show messages during optimisation</span>
    DoReport  <a href="/pkg/builtin/#bool">bool</a>       <span class="comment">// generate report</span>
    Json      <a href="/pkg/builtin/#bool">bool</a>       <span class="comment">// output results as .json files; not tables</span>
    DirOut    <a href="/pkg/builtin/#string">string</a>     <span class="comment">// directory to save output files. &#34;&#34; means &#34;/tmp/goga&#34;</span>
    FnKey     <a href="/pkg/builtin/#string">string</a>     <span class="comment">// filename key for output files. &#34;&#34; means no output files</span>
    DoPlot    <a href="/pkg/builtin/#bool">bool</a>       <span class="comment">// plot results</span>
    PltTi     <a href="/pkg/builtin/#int">int</a>        <span class="comment">// initial time for plot</span>
    PltTf     <a href="/pkg/builtin/#int">int</a>        <span class="comment">// final time for plot</span>
    ShowOor   <a href="/pkg/builtin/#bool">bool</a>       <span class="comment">// show oor values when printing results (if any)</span>
    ShowBases <a href="/pkg/builtin/#bool">bool</a>       <span class="comment">// show also bases when printing results (if any)</span>
    ShowNinds <a href="/pkg/builtin/#int">int</a>        <span class="comment">// number of individuals to show. use -1 to show all</span>
    PostProc  <a href="#PostProc_t">PostProc_t</a> <span class="comment">// function to post-process results</span>

    <span class="comment">// auxiliary</span>
    Problem  <a href="/pkg/builtin/#int">int</a>     <span class="comment">// problem ID</span>
    Strategy <a href="/pkg/builtin/#int">int</a>     <span class="comment">// strategy for implementing constraints</span>
    Ntrials  <a href="/pkg/builtin/#int">int</a>     <span class="comment">// number of trials</span>
    Eps1     <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// tolerance # 1; e.g. for strategy # 2 in reliability analyses</span>

    <span class="comment">// objective function</span>
    OvaOor <a href="#Objectives_t">Objectives_t</a> <span class="comment">// compute objective value (ova) and out-of-range value (oor)</span>

    <span class="comment">// generation of individuals</span>
    NumInts  <a href="/pkg/builtin/#int">int</a>         <span class="comment">// number of integers for &#34;ordered&#34; and &#34;binary&#34; populations</span>
    RangeInt [][]<a href="/pkg/builtin/#int">int</a>     <span class="comment">// [ngene][2] min and max integers</span>
    RangeFlt [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [ngene][2] min and max float point numbers</span>
    PoolStr  [][]<a href="/pkg/builtin/#string">string</a>  <span class="comment">// [ngene][nsamples] pool of words to be used in Gene.String</span>
    PoolKey  [][]<a href="/pkg/builtin/#byte">byte</a>    <span class="comment">// [ngene][nsamples] pool of bytes to be used in Gene.Byte</span>
    PoolByt  [][]<a href="/pkg/builtin/#string">string</a>  <span class="comment">// [ngene][nsamples] pool of byte-words to be used in Gene.Bytes</span>
    PoolFun  [][]<a href="#Func_t">Func_t</a>  <span class="comment">// [ngene][nsamples] pool of functions</span>

    <span class="comment">// generation of populations</span>
    PopIntGen <a href="#PopIntGen_t">PopIntGen_t</a> <span class="comment">// generate population of integers</span>
    PopFltGen <a href="#PopFltGen_t">PopFltGen_t</a> <span class="comment">// generate population of float point numbers</span>
    PopStrGen <a href="#PopStrGen_t">PopStrGen_t</a> <span class="comment">// generate population of strings</span>
    PopKeyGen <a href="#PopKeyGen_t">PopKeyGen_t</a> <span class="comment">// generate population of keys (bytes)</span>
    PopBytGen <a href="#PopBytGen_t">PopBytGen_t</a> <span class="comment">// generate population of bytes</span>
    PopFunGen <a href="#PopFunGen_t">PopFunGen_t</a> <span class="comment">// generate population of functions</span>
}</pre>
			<p>
ConfParams is an auxiliary structure to hold configuration parameters for setting the GA up
</p>


			

			

			
			
			

			
				
				<h3 id="NewConfParams">func <a href="https://github.com/cpmech/goga/blob/master//params.go?s=5574:5606#L170">NewConfParams</a></h3>
				<pre>func NewConfParams() *<a href="#ConfParams">ConfParams</a></pre>
				<p>
NewConfParams returns a new ConfParams structure, with default values set
</p>

				
				
			
				
				<h3 id="ReadConfParams">func <a href="https://github.com/cpmech/goga/blob/master//params.go?s=5721:5773#L177">ReadConfParams</a></h3>
				<pre>func ReadConfParams(filenamepath <a href="/pkg/builtin/#string">string</a>) *<a href="#ConfParams">ConfParams</a></pre>
				<p>
ReadConfParams reads configuration parameters from JSON file
</p>

				
				
			

			
				
				<h3 id="ConfParams.CalcDerived">func (*ConfParams) <a href="https://github.com/cpmech/goga/blob/master//params.go?s=5420:5454#L165">CalcDerived</a></h3>
				<pre>func (o *<a href="#ConfParams">ConfParams</a>) CalcDerived()</pre>
				<p>
CalcDerived calculates derived quantities
</p>

				
				
				
			
				
				<h3 id="ConfParams.SetDefault">func (*ConfParams) <a href="https://github.com/cpmech/goga/blob/master//params.go?s=3942:3975#L84">SetDefault</a></h3>
				<pre>func (o *<a href="#ConfParams">ConfParams</a>) SetDefault()</pre>
				<p>
SetDefault sets default parameters
</p>

				
				
				
			
				
				<h3 id="ConfParams.SetIntBin">func (*ConfParams) <a href="https://github.com/cpmech/goga/blob/master//params.go?s=5013:5053#L149">SetIntBin</a></h3>
				<pre>func (o *<a href="#ConfParams">ConfParams</a>) SetIntBin(size <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
SetIntBin sets functions to handle binary numbers [0,1]
</p>

				
				
				
			
				
				<h3 id="ConfParams.SetIntOrd">func (*ConfParams) <a href="https://github.com/cpmech/goga/blob/master//params.go?s=5215:5260#L157">SetIntOrd</a></h3>
				<pre>func (o *<a href="#ConfParams">ConfParams</a>) SetIntOrd(nstations <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
SetIntOrd sets functions to handle ordered integers
</p>

				
				
				
			
				
				<h3 id="ConfParams.SetNbasesFixOp">func (*ConfParams) <a href="https://github.com/cpmech/goga/blob/master//params.go?s=4827:4874#L142">SetNbasesFixOp</a></h3>
				<pre>func (o *<a href="#ConfParams">ConfParams</a>) SetNbasesFixOp(nbases <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
SetNbases sets number of bases and fixes corresponding operators
</p>

				
				
				
			
		
			
			
			<h2 id="CxBytFunc_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=1997:2076#L32">CxBytFunc_t</a></h2>
			<pre>type CxBytFunc_t func(a, b, A, B [][]<a href="/pkg/builtin/#byte">byte</a>, time <a href="/pkg/builtin/#int">int</a>, dat *<a href="#OpsData">OpsData</a>) (ends []<a href="/pkg/builtin/#int">int</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="CxFltFunc_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=1758:1838#L29">CxFltFunc_t</a></h2>
			<pre>type CxFltFunc_t func(a, b, A, B []<a href="/pkg/builtin/#float64">float64</a>, time <a href="/pkg/builtin/#int">int</a>, dat *<a href="#OpsData">OpsData</a>) (ends []<a href="/pkg/builtin/#int">int</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="CxFunFunc_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=2077:2156#L33">CxFunFunc_t</a></h2>
			<pre>type CxFunFunc_t func(a, b, A, B []<a href="#Func_t">Func_t</a>, time <a href="/pkg/builtin/#int">int</a>, dat *<a href="#OpsData">OpsData</a>) (ends []<a href="/pkg/builtin/#int">int</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="CxIntFunc_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=1681:1757#L28">CxIntFunc_t</a></h2>
			<pre>type CxIntFunc_t func(a, b, A, B []<a href="/pkg/builtin/#int">int</a>, time <a href="/pkg/builtin/#int">int</a>, dat *<a href="#OpsData">OpsData</a>) (ends []<a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
crossover functions
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="CxKeyFunc_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=1919:1996#L31">CxKeyFunc_t</a></h2>
			<pre>type CxKeyFunc_t func(a, b, A, B []<a href="/pkg/builtin/#byte">byte</a>, time <a href="/pkg/builtin/#int">int</a>, dat *<a href="#OpsData">OpsData</a>) (ends []<a href="/pkg/builtin/#int">int</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="CxStrFunc_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=1839:1918#L30">CxStrFunc_t</a></h2>
			<pre>type CxStrFunc_t func(a, b, A, B []<a href="/pkg/builtin/#string">string</a>, time <a href="/pkg/builtin/#int">int</a>, dat *<a href="#OpsData">OpsData</a>) (ends []<a href="/pkg/builtin/#int">int</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="Evolver">type <a href="https://github.com/cpmech/goga/blob/master//evolver.go?s=331:500#L4">Evolver</a></h2>
			<pre>type Evolver struct {
    C       *<a href="#ConfParams">ConfParams</a> <span class="comment">// configuration parameters</span>
    Islands []*<a href="#Island">Island</a>   <span class="comment">// islands</span>
    Best    *<a href="#Individual">Individual</a> <span class="comment">// best individual among all in all islands</span>
}</pre>
			<p>
Evolver realises the evolutionary process
</p>


			

			

			
			
			

			
				
				<h3 id="NewEvolver">func <a href="https://github.com/cpmech/goga/blob/master//evolver.go?s=568:627#L11">NewEvolver</a></h3>
				<pre>func NewEvolver(nova, noor <a href="/pkg/builtin/#int">int</a>, C *<a href="#ConfParams">ConfParams</a>) (o *<a href="#Evolver">Evolver</a>)</pre>
				<p>
NewEvolverPop creates a new evolver based on given populations
</p>

				
				
			

			
				
				<h3 id="Evolver.FindBestFromAll">func (*Evolver) <a href="https://github.com/cpmech/goga/blob/master//evolver.go?s=3807:3842#L174">FindBestFromAll</a></h3>
				<pre>func (o *<a href="#Evolver">Evolver</a>) FindBestFromAll()</pre>
				<p>
FindBestFromAll finds best individual from all islands
</p>
<pre>Output: o.Best will point to the best individual
</pre>

				
				
				
			
				
				<h3 id="Evolver.GetFeasible">func (*Evolver) <a href="https://github.com/cpmech/goga/blob/master//evolver.go?s=4142:4198#L188">GetFeasible</a></h3>
				<pre>func (o *<a href="#Evolver">Evolver</a>) GetFeasible() (feasible []*<a href="#Individual">Individual</a>)</pre>
				<p>
GetFeasible returns all feasible individuals from all islands
</p>

				
				
				
			
				
				<h3 id="Evolver.GetFrontOvas">func (*Evolver) <a href="https://github.com/cpmech/goga/blob/master//evolver.go?s=5824:5902#L249">GetFrontOvas</a></h3>
				<pre>func (o *<a href="#Evolver">Evolver</a>) GetFrontOvas(r, s <a href="/pkg/builtin/#int">int</a>, front []*<a href="#Individual">Individual</a>) (x, y []<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
GetFrontOvas collects 2 ova results from Pareto front
</p>
<pre>Input:
 r and s -- 2 selected objective functions; e.g. r=0 and s=1 for 2D problems
</pre>

				
				
				
			
				
				<h3 id="Evolver.GetParetoFront">func (*Evolver) <a href="https://github.com/cpmech/goga/blob/master//evolver.go?s=5169:5284#L228">GetParetoFront</a></h3>
				<pre>func (o *<a href="#Evolver">Evolver</a>) GetParetoFront(feasible []*<a href="#Individual">Individual</a>, ovas, oors [][]<a href="/pkg/builtin/#float64">float64</a>) (ovafront, oorfront []*<a href="#Individual">Individual</a>)</pre>
				<p>
GetParetoFront returns all feasible individuals on the Pareto front
Note: input data can be obtained from GetFeasible and GetResults
</p>

				
				
				
			
				
				<h3 id="Evolver.GetResults">func (*Evolver) <a href="https://github.com/cpmech/goga/blob/master//evolver.go?s=4638:4713#L209">GetResults</a></h3>
				<pre>func (o *<a href="#Evolver">Evolver</a>) GetResults(subset []*<a href="#Individual">Individual</a>) (ovas, oors [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
GetResults returns all ovas and oors from a subset of individuals
</p>
<pre>Output:
 ovas -- [len(subset)][nova] objective values
 oors -- [len(subset)][noor] out-of-range values
</pre>

				
				
				
			
				
				<h3 id="Evolver.Run">func (*Evolver) <a href="https://github.com/cpmech/goga/blob/master//evolver.go?s=854:877#L23">Run</a></h3>
				<pre>func (o *<a href="#Evolver">Evolver</a>) Run()</pre>
				<p>
Run runs the evolution process
</p>

				
				
				
			
		
			
			
			<h2 id="Func_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=391:431#L3">Func_t</a></h2>
			<pre>type Func_t func(ind *<a href="#Individual">Individual</a>) <a href="/pkg/builtin/#string">string</a></pre>
			<p>
Func_t defines a type for a generic function to be used as a gene value
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Individual">type <a href="https://github.com/cpmech/goga/blob/master//individual.go?s=380:989#L7">Individual</a></h2>
			<pre>type Individual struct {

    <span class="comment">// data</span>
    Ovas      []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// objective values</span>
    Oors      []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// out-of-range values: sum of positive distances from constraints</span>
    Demerit   <a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// quantity for comparing individuals. 0=good 1=bad 2=worse(oor) 3=worst(oor)</span>
    Nfltgenes <a href="/pkg/builtin/#int">int</a>       <span class="comment">// number of floats == number of float64 genes</span>
    Nbases    <a href="/pkg/builtin/#int">int</a>       <span class="comment">// number of bases to split Floats</span>

    <span class="comment">// chromosome</span>
    Ints    []<a href="/pkg/builtin/#int">int</a>     <span class="comment">// integers</span>
    Floats  []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// floats [nFLTgenes * nbases]</span>
    Strings []<a href="/pkg/builtin/#string">string</a>  <span class="comment">// strings</span>
    Keys    []<a href="/pkg/builtin/#byte">byte</a>    <span class="comment">// 1D bytes</span>
    Bytes   [][]<a href="/pkg/builtin/#byte">byte</a>  <span class="comment">// 2D bytes</span>
    Funcs   []<a href="#Func_t">Func_t</a>  <span class="comment">// functions</span>
}</pre>
			<p>
Individual implements one individual in a population
</p>


			

			

			
			
			

			
				
				<h3 id="NewIndividual">func <a href="https://github.com/cpmech/goga/blob/master//individual.go?s=1342:1423#L32">NewIndividual</a></h3>
				<pre>func NewIndividual(nova, noor, nbases <a href="/pkg/builtin/#int">int</a>, slices ...interface{}) (o *<a href="#Individual">Individual</a>)</pre>
				<p>
NewIndividual allocates a new individual
</p>
<pre>Input:
 nbases -- used to split genes of floats into smaller parts
 slices -- slices of ints, floats, strings, bytes, []bytes, and/or Func_t
Notes:
 1) the slices in &#39;genes&#39; can all be combined to define genes with mixed data;
 2) the slices can also be nil, except for one of them.
</pre>

				
				
			

			
				
				<h3 id="Individual.CopyInto">func (Individual) <a href="https://github.com/cpmech/goga/blob/master//individual.go?s=3238:3281#L123">CopyInto</a></h3>
				<pre>func (o <a href="#Individual">Individual</a>) CopyInto(x *<a href="#Individual">Individual</a>)</pre>
				<p>
CopyInto copies this individual&#39;s data into another individual
</p>

				
				
				
			
				
				<h3 id="Individual.GetCopy">func (Individual) <a href="https://github.com/cpmech/goga/blob/master//individual.go?s=2282:2327#L76">GetCopy</a></h3>
				<pre>func (o <a href="#Individual">Individual</a>) GetCopy() (x *<a href="#Individual">Individual</a>)</pre>
				<p>
GetCopy returns a copy of this individual
</p>

				
				
				
			
				
				<h3 id="Individual.GetFloat">func (Individual) <a href="https://github.com/cpmech/goga/blob/master//individual.go?s=7391:7442#L296">GetFloat</a></h3>
				<pre>func (o <a href="#Individual">Individual</a>) GetFloat(igene <a href="/pkg/builtin/#int">int</a>) (x <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
GetFloat returns the float corresponding to gene &#39;i&#39;
</p>
<pre>igene -- is the index of gene/float in [0, Nfltgenes]
</pre>

				
				
				
			
				
				<h3 id="Individual.GetFloats">func (Individual) <a href="https://github.com/cpmech/goga/blob/master//individual.go?s=7613:7658#L307">GetFloats</a></h3>
				<pre>func (o <a href="#Individual">Individual</a>) GetFloats() (x []<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
GetFloats returns all float genes
</p>

				
				
				
			
				
				<h3 id="Individual.GetStringSizes">func (*Individual) <a href="https://github.com/cpmech/goga/blob/master//individual.go?s=8026:8079#L319">GetStringSizes</a></h3>
				<pre>func (o *<a href="#Individual">Individual</a>) GetStringSizes() (sizes [][]<a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
GetStringSizes returns the sizes of strings representing each gene type
</p>
<pre>sizes -- [6][...] sizes of strings for {int, flt, string, byte, bytes, func}
</pre>

				
				
				
			
				
				<h3 id="Individual.Output">func (*Individual) <a href="https://github.com/cpmech/goga/blob/master//individual.go?s=9456:9527#L377">Output</a></h3>
				<pre>func (o *<a href="#Individual">Individual</a>) Output(fmts [][]<a href="/pkg/builtin/#string">string</a>, showBases <a href="/pkg/builtin/#bool">bool</a>) (l <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
Output returns a string representation of this individual
</p>
<pre>fmts      -- [6][...] formats of strings for {int, flt, string, byte, bytes, func}
             use fmts == nil to choose default ones
showBases -- show bases, if any
</pre>

				
				
				
			
				
				<h3 id="Individual.SetFloat">func (*Individual) <a href="https://github.com/cpmech/goga/blob/master//individual.go?s=6982:7033#L281">SetFloat</a></h3>
				<pre>func (o *<a href="#Individual">Individual</a>) SetFloat(igene <a href="/pkg/builtin/#int">int</a>, x <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
SetFloat returns the float corresponding to gene &#39;i&#39;
</p>
<pre>igene -- is the index of gene/float in [0, Nfltgenes]
</pre>

				
				
				
			
		
			
			
			<h2 id="Island">type <a href="https://github.com/cpmech/goga/blob/master//island.go?s=466:2098#L10">Island</a></h2>
			<pre>type Island struct {

    <span class="comment">// input</span>
    Id  <a href="/pkg/builtin/#int">int</a>         <span class="comment">// index of this island</span>
    C   *<a href="#ConfParams">ConfParams</a> <span class="comment">// configuration parameters</span>
    Pop <a href="#Population">Population</a>  <span class="comment">// pointer to current population</span>
    Bkp <a href="#Population">Population</a>  <span class="comment">// backup population</span>

    <span class="comment">// results</span>
    Report   <a href="/pkg/bytes/">bytes</a>.<a href="/pkg/bytes/#Buffer">Buffer</a> <span class="comment">// buffer to report results</span>
    Nova     <a href="/pkg/builtin/#int">int</a>          <span class="comment">// number of ovas</span>
    Noor     <a href="/pkg/builtin/#int">int</a>          <span class="comment">// number of oors</span>
    OutOvas  [][]<a href="/pkg/builtin/#float64">float64</a>  <span class="comment">// [nova][ntimes] best objective values collected from multiple calls to SelectReprodAndRegen</span>
    OutOors  [][]<a href="/pkg/builtin/#float64">float64</a>  <span class="comment">// [noor][ntimes] best out-of-range values collected from multiple calls to SelectReprodAndRegen</span>
    OutTimes []<a href="/pkg/builtin/#float64">float64</a>    <span class="comment">// [ntimes] times corresponding to OutOvas and OutOors</span>

    A, B []<a href="/pkg/builtin/#int">int</a> <span class="comment">// indices of selected parents</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Island holds one population and performs the reproduction operation
</p>


			

			

			
			
			

			
				
				<h3 id="NewIsland">func <a href="https://github.com/cpmech/goga/blob/master//island.go?s=2134:2195#L54">NewIsland</a></h3>
				<pre>func NewIsland(id, nova, noor <a href="/pkg/builtin/#int">int</a>, C *<a href="#ConfParams">ConfParams</a>) (o *<a href="#Island">Island</a>)</pre>
				<p>
NewIsland creates a new island
</p>

				
				
			

			
				
				<h3 id="Island.CalcDemeritsAndSort">func (*Island) <a href="https://github.com/cpmech/goga/blob/master//island.go?s=5298:5350#L161">CalcDemeritsAndSort</a></h3>
				<pre>func (o *<a href="#Island">Island</a>) CalcDemeritsAndSort(pop <a href="#Population">Population</a>)</pre>
				<p>
CalcDemeritsAndSort computes demerits and sort population
</p>

				
				
				
			
				
				<h3 id="Island.CalcOvs">func (*Island) <a href="https://github.com/cpmech/goga/blob/master//island.go?s=4916:4966#L149">CalcOvs</a></h3>
				<pre>func (o *<a href="#Island">Island</a>) CalcOvs(pop <a href="#Population">Population</a>, time <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
CalcOvs computes objective and out-of-range values
</p>

				
				
				
			
				
				<h3 id="Island.FltStat">func (*Island) <a href="https://github.com/cpmech/goga/blob/master//island.go?s=12308:12375#L453">FltStat</a></h3>
				<pre>func (o *<a href="#Island">Island</a>) FltStat() (minrho, averho, maxrho, devrho <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
FltStat computes some statistic information with float-point individuals
</p>
<pre>rho (ρ) is a normalised quantity measuring the deviation of bases of each gene
</pre>

				
				
				
			
				
				<h3 id="Island.Regenerate">func (*Island) <a href="https://github.com/cpmech/goga/blob/master//island.go?s=11743:11780#L436">Regenerate</a></h3>
				<pre>func (o *<a href="#Island">Island</a>) Regenerate(time <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Regenerate regenerates population with basis on best individual(s)
</p>

				
				
				
			
				
				<h3 id="Island.Run">func (*Island) <a href="https://github.com/cpmech/goga/blob/master//island.go?s=6153:6207#L199">Run</a></h3>
				<pre>func (o *<a href="#Island">Island</a>) Run(time <a href="/pkg/builtin/#int">int</a>, doreport, verbose <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Run runs evolutionary process
</p>

				
				
				
			
				
				<h3 id="Island.SaveReport">func (Island) <a href="https://github.com/cpmech/goga/blob/master//island.go?s=13340:13380#L485">SaveReport</a></h3>
				<pre>func (o <a href="#Island">Island</a>) SaveReport(verbose <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SaveReport saves report to file
</p>

				
				
				
			
				
				<h3 id="Island.WritePopToReport">func (*Island) <a href="https://github.com/cpmech/goga/blob/master//island.go?s=13099:13158#L479">WritePopToReport</a></h3>
				<pre>func (o *<a href="#Island">Island</a>) WritePopToReport(time <a href="/pkg/builtin/#int">int</a>, averho <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
WritePopToReport writes population to report
</p>

				
				
				
			
		
			
			
			<h2 id="MtBytFunc_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=2408:2465#L40">MtBytFunc_t</a></h2>
			<pre>type MtBytFunc_t func(a [][]<a href="/pkg/builtin/#byte">byte</a>, time <a href="/pkg/builtin/#int">int</a>, dat *<a href="#OpsData">OpsData</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="MtFltFunc_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=2235:2293#L37">MtFltFunc_t</a></h2>
			<pre>type MtFltFunc_t func(a []<a href="/pkg/builtin/#float64">float64</a>, time <a href="/pkg/builtin/#int">int</a>, dat *<a href="#OpsData">OpsData</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="MtFunFunc_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=2466:2523#L41">MtFunFunc_t</a></h2>
			<pre>type MtFunFunc_t func(a []<a href="#Func_t">Func_t</a>, time <a href="/pkg/builtin/#int">int</a>, dat *<a href="#OpsData">OpsData</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="MtIntFunc_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=2180:2234#L36">MtIntFunc_t</a></h2>
			<pre>type MtIntFunc_t func(a []<a href="/pkg/builtin/#int">int</a>, time <a href="/pkg/builtin/#int">int</a>, dat *<a href="#OpsData">OpsData</a>)</pre>
			<p>
mutation functions
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="MtKeyFunc_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=2352:2407#L39">MtKeyFunc_t</a></h2>
			<pre>type MtKeyFunc_t func(a []<a href="/pkg/builtin/#byte">byte</a>, time <a href="/pkg/builtin/#int">int</a>, dat *<a href="#OpsData">OpsData</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="MtStrFunc_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=2294:2351#L38">MtStrFunc_t</a></h2>
			<pre>type MtStrFunc_t func(a []<a href="/pkg/builtin/#string">string</a>, time <a href="/pkg/builtin/#int">int</a>, dat *<a href="#OpsData">OpsData</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="Objectives_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=548:629#L7">Objectives_t</a></h2>
			<pre>type Objectives_t func(ind *<a href="#Individual">Individual</a>, idIsland, time <a href="/pkg/builtin/#int">int</a>, report *<a href="/pkg/bytes/">bytes</a>.<a href="/pkg/bytes/#Buffer">Buffer</a>)</pre>
			<p>
Objectives_t defines the template for the objective functions and constraints.
ind is set with ovas and oors
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="OpsData">type <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=405:1686#L9">OpsData</a></h2>
			<pre>type OpsData struct {

    <span class="comment">// constants</span>
    Pc       <a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// probability of crossover</span>
    Pm       <a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// probability of mutation</span>
    Ncuts    <a href="/pkg/builtin/#int">int</a>         <span class="comment">// number of cuts during crossover</span>
    Nchanges <a href="/pkg/builtin/#int">int</a>         <span class="comment">// number of changes during mutation</span>
    Tmax     <a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// max number of generations</span>
    MwiczB   <a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// Michalewicz&#39; power coefficient</span>
    BlxAlp   <a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// BLX-α coefficient</span>
    Mmax     <a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// multiplier for mutation</span>
    Cuts     []<a href="/pkg/builtin/#int">int</a>       <span class="comment">// specified cuts for crossover. can be &lt;nil&gt;</span>
    OrdSti   []<a href="/pkg/builtin/#int">int</a>       <span class="comment">// {start, end, insertPoint}. can be &lt;nil&gt;</span>
    Xrange   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [ngenes][2] genes minimum and maximum values</span>
    EnfRange <a href="/pkg/builtin/#bool">bool</a>        <span class="comment">// do enforce range</span>

    <span class="comment">// crossover functions</span>
    CxInt <a href="#CxIntFunc_t">CxIntFunc_t</a> <span class="comment">// int crossover function</span>
    CxFlt <a href="#CxFltFunc_t">CxFltFunc_t</a> <span class="comment">// flt crossover function</span>
    CxStr <a href="#CxStrFunc_t">CxStrFunc_t</a> <span class="comment">// str crossover function</span>
    CxKey <a href="#CxKeyFunc_t">CxKeyFunc_t</a> <span class="comment">// key crossover function</span>
    CxByt <a href="#CxBytFunc_t">CxBytFunc_t</a> <span class="comment">// byt crossover function</span>
    CxFun <a href="#CxFunFunc_t">CxFunFunc_t</a> <span class="comment">// fun crossover function</span>

    <span class="comment">// mutation functions</span>
    MtInt <a href="#MtIntFunc_t">MtIntFunc_t</a> <span class="comment">// int mutation function</span>
    MtFlt <a href="#MtFltFunc_t">MtFltFunc_t</a> <span class="comment">// flt mutation function</span>
    MtStr <a href="#MtStrFunc_t">MtStrFunc_t</a> <span class="comment">// str mutation function</span>
    MtKey <a href="#MtKeyFunc_t">MtKeyFunc_t</a> <span class="comment">// key mutation function</span>
    MtByt <a href="#MtBytFunc_t">MtBytFunc_t</a> <span class="comment">// byt mutation function</span>
    MtFun <a href="#MtFunFunc_t">MtFunFunc_t</a> <span class="comment">// fun mutation function</span>
}</pre>
			<p>
OpsData holds data for crossover and mutation operators
</p>


			

			

			
			
			

			

			
				
				<h3 id="OpsData.CalcDerived">func (*OpsData) <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=2249:2306#L72">CalcDerived</a></h3>
				<pre>func (o *<a href="#OpsData">OpsData</a>) CalcDerived(Tf <a href="/pkg/builtin/#int">int</a>, xrange [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
CalcDerived sets derived quantities
</p>

				
				
				
			
				
				<h3 id="OpsData.EnforceRange">func (*OpsData) <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=2595:2655#L84">EnforceRange</a></h3>
				<pre>func (o *<a href="#OpsData">OpsData</a>) EnforceRange(igene <a href="/pkg/builtin/#int">int</a>, x <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
EnforceRange makes sure x is within given range
</p>

				
				
				
			
				
				<h3 id="OpsData.MwiczDelta">func (*OpsData) <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=2401:2451#L78">MwiczDelta</a></h3>
				<pre>func (o *<a href="#OpsData">OpsData</a>) MwiczDelta(t, x <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
MwiczDelta computes Michalewicz&#39; Δ function
</p>

				
				
				
			
				
				<h3 id="OpsData.SetDefault">func (*OpsData) <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=1722:1752#L43">SetDefault</a></h3>
				<pre>func (o *<a href="#OpsData">OpsData</a>) SetDefault()</pre>
				<p>
SetDefault sets default values
</p>

				
				
				
			
		
			
			
			<h2 id="PopBytGen_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=1396:1491#L22">PopBytGen_t</a></h2>
			<pre>type PopBytGen_t func(ninds, nova, noor, nbases <a href="/pkg/builtin/#int">int</a>, noise <a href="/pkg/builtin/#float64">float64</a>, pool [][]<a href="/pkg/builtin/#string">string</a>) <a href="#Population">Population</a></pre>
			<p>
PopBytGen_t defines function to generate population of bytes
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="PopFltGen_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=903:1001#L13">PopFltGen_t</a></h2>
			<pre>type PopFltGen_t func(ninds, nova, noor, nbases <a href="/pkg/builtin/#int">int</a>, noise <a href="/pkg/builtin/#float64">float64</a>, frange [][]<a href="/pkg/builtin/#float64">float64</a>) <a href="#Population">Population</a></pre>
			<p>
PopFltGen_t defines function to generate population of float point numbers
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="PopFunGen_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=1561:1656#L25">PopFunGen_t</a></h2>
			<pre>type PopFunGen_t func(ninds, nova, noor, nbases <a href="/pkg/builtin/#int">int</a>, noise <a href="/pkg/builtin/#float64">float64</a>, pool [][]<a href="#Func_t">Func_t</a>) <a href="#Population">Population</a></pre>
			<p>
PopFunGen_t defines function to generate population of functions
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="PopIntGen_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=698:823#L10">PopIntGen_t</a></h2>
			<pre>type PopIntGen_t func(ninds, nova, noor, nbases <a href="/pkg/builtin/#int">int</a>, noise <a href="/pkg/builtin/#float64">float64</a>, nints_or_unused <a href="/pkg/builtin/#int">int</a>, irange_or_unused [][]<a href="/pkg/builtin/#int">int</a>) <a href="#Population">Population</a></pre>
			<p>
PopIntGen_t defines function to generate population of integers
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="PopKeyGen_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=1237:1330#L19">PopKeyGen_t</a></h2>
			<pre>type PopKeyGen_t func(ninds, nova, noor, nbases <a href="/pkg/builtin/#int">int</a>, noise <a href="/pkg/builtin/#float64">float64</a>, pool [][]<a href="/pkg/builtin/#byte">byte</a>) <a href="#Population">Population</a></pre>
			<p>
PopKeyGen_t defines function to generate population of keys (bytes)
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="PopStrGen_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=1069:1164#L16">PopStrGen_t</a></h2>
			<pre>type PopStrGen_t func(ninds, nova, noor, nbases <a href="/pkg/builtin/#int">int</a>, noise <a href="/pkg/builtin/#float64">float64</a>, pool [][]<a href="/pkg/builtin/#string">string</a>) <a href="#Population">Population</a></pre>
			<p>
PopStrGen_t defines function to generate population of strings
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Population">type <a href="https://github.com/cpmech/goga/blob/master//population.go?s=361:390#L9">Population</a></h2>
			<pre>type Population []*<a href="#Individual">Individual</a></pre>
			<p>
Population holds all individuals
</p>


			

			

			
			
			

			
				
				<h3 id="PopBinGen">func <a href="https://github.com/cpmech/goga/blob/master//population.go?s=452:550#L12">PopBinGen</a></h3>
				<pre>func PopBinGen(ninds, nova, noor, nbases <a href="/pkg/builtin/#int">int</a>, noise <a href="/pkg/builtin/#float64">float64</a>, nints <a href="/pkg/builtin/#int">int</a>, unused [][]<a href="/pkg/builtin/#int">int</a>) <a href="#Population">Population</a></pre>
				<p>
PopBinGen generates a population of binary numbers [0,1]
</p>

				
				
			
				
				<h3 id="PopFltGen">func <a href="https://github.com/cpmech/goga/blob/master//population.go?s=890:981#L26">PopFltGen</a></h3>
				<pre>func PopFltGen(ninds, nova, noor, nbases <a href="/pkg/builtin/#int">int</a>, noise <a href="/pkg/builtin/#float64">float64</a>, frange [][]<a href="/pkg/builtin/#float64">float64</a>) <a href="#Population">Population</a></pre>
				<p>
PopFltGen generates a population of individuals with float point numbers
Notes: (1) ngenes = len(frange)
</p>

				
				
			
				
				<h3 id="PopOrdGen">func <a href="https://github.com/cpmech/goga/blob/master//population.go?s=2532:2630#L83">PopOrdGen</a></h3>
				<pre>func PopOrdGen(ninds, nova, noor, nbases <a href="/pkg/builtin/#int">int</a>, noise <a href="/pkg/builtin/#float64">float64</a>, nints <a href="/pkg/builtin/#int">int</a>, unused [][]<a href="/pkg/builtin/#int">int</a>) <a href="#Population">Population</a></pre>
				<p>
PopOrdGen generates a population of individuals with ordered integers
Notes: (1) ngenes = len(frange)
</p>

				
				
			

			
				
				<h3 id="Population.GetCopy">func (Population) <a href="https://github.com/cpmech/goga/blob/master//population.go?s=3023:3069#L99">GetCopy</a></h3>
				<pre>func (o <a href="#Population">Population</a>) GetCopy() (pop <a href="#Population">Population</a>)</pre>
				<p>
GetCopy returns a copy of this population
</p>

				
				
				
			
				
				<h3 id="Population.Len">func (Population) <a href="https://github.com/cpmech/goga/blob/master//population.go?s=3262:3291#L109">Len</a></h3>
				<pre>func (o <a href="#Population">Population</a>) Len() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Len returns the length of the population == number of individuals
</p>

				
				
				
			
				
				<h3 id="Population.Less">func (Population) <a href="https://github.com/cpmech/goga/blob/master//population.go?s=3562:3601#L120">Less</a></h3>
				<pre>func (o <a href="#Population">Population</a>) Less(i, j <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Less returns true if &#39;i&#39; is &#34;less bad&#34; than &#39;j&#39;; therefore it can be used
to sort the population in increasing order of demerits: from best to worst
</p>

				
				
				
			
				
				<h3 id="Population.OutFloatBases">func (Population) <a href="https://github.com/cpmech/goga/blob/master//population.go?s=7102:7161#L268">OutFloatBases</a></h3>
				<pre>func (o <a href="#Population">Population</a>) OutFloatBases(numFmt <a href="/pkg/builtin/#string">string</a>) (l <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
OutFloatBases print bases of float genes
</p>

				
				
				
			
				
				<h3 id="Population.Output">func (Population) <a href="https://github.com/cpmech/goga/blob/master//population.go?s=4017:4120#L134">Output</a></h3>
				<pre>func (o <a href="#Population">Population</a>) Output(fmts [][]<a href="/pkg/builtin/#string">string</a>, showOor, showBases <a href="/pkg/builtin/#bool">bool</a>, showNinds <a href="/pkg/builtin/#int">int</a>) (buf *<a href="/pkg/bytes/">bytes</a>.<a href="/pkg/bytes/#Buffer">Buffer</a>)</pre>
				<p>
Output generates a nice table with population data
</p>
<pre>Input:
fmts      -- [ngenes] formats for int, flt, string, byte, bytes, and func
             use fmts == nil to choose default ones
showBases -- show bases, if any
</pre>

				
				
				
			
				
				<h3 id="Population.Sort">func (*Population) <a href="https://github.com/cpmech/goga/blob/master//population.go?s=3735:3762#L125">Sort</a></h3>
				<pre>func (o *<a href="#Population">Population</a>) Sort()</pre>
				<p>
Sort sorts the population from best to worst individuals; i.e. decreasing fitness values
</p>

				
				
				
			
				
				<h3 id="Population.Swap">func (Population) <a href="https://github.com/cpmech/goga/blob/master//population.go?s=3342:3376#L114">Swap</a></h3>
				<pre>func (o <a href="#Population">Population</a>) Swap(i, j <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Swap swaps two individuals
</p>

				
				
				
			
		
			
			
			<h2 id="PostProc_t">type <a href="https://github.com/cpmech/goga/blob/master//definitions.go?s=258:314#L1">PostProc_t</a></h2>
			<pre>type PostProc_t func(idIsland, time <a href="/pkg/builtin/#int">int</a>, pop <a href="#Population">Population</a>)</pre>
			<p>
PostProc_t defines a function to post-process results
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="TwoVarsFunc_t">type <a href="https://github.com/cpmech/goga/blob/master//plotting.go?s=410:454#L6">TwoVarsFunc_t</a></h2>
			<pre>type TwoVarsFunc_t func(x []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
TwoVarsFunc_t defines a function to plot contours (len(x)==2)
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="TwoVarsTrans_t">type <a href="https://github.com/cpmech/goga/blob/master//plotting.go?s=526:591#L9">TwoVarsTrans_t</a></h2>
			<pre>type TwoVarsTrans_t func(x []<a href="/pkg/builtin/#float64">float64</a>) (y []<a href="/pkg/builtin/#float64">float64</a>, invalid <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
TwoVarsTrans_t defines a tranformation x → y (len(x)==len(y)==2)
</p>


			

			

			
			
			

			

			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		<tr>
		<td><a href="..">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="data/">data</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="doc/">doc</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="examples/">examples</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
	</table>

	

</dl>
</div><!-- manual-nav -->
</div><!-- page -->
<div id="footer">
<br /><br />
<hr>
<pre class="copyright">
Copyright (c) 2015, Dorival Pedroso
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of goga nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

</pre><!-- copyright -->
</div><!-- footer -->
</body>
</html>
