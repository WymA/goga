<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Goga &ndash; Documentation</title>
<link type="text/css" rel="stylesheet" href="static/style.css">
<script type="text/javascript" src="static/godocs.js"></script>
<style type="text/css"></style>
</head>
<body>
<div id="page">
<h1>Goga &ndash; Documentation</h1>
<h2 id="pkg-index">Index</h2>
<div id="manual-nav">
<dl>
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = ;
	document.CALLGRAPH = ;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/cpmech/goga"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				
			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
			
				
				<dd><a href="#CxFltDE">func CxFltDE(a, b, A, B, x0, x1, x2, y0, y1, y2 []float64, prms *Parameters)</a></dd>
			
				
				<dd><a href="#CxInt">func CxInt(a, b, A, B []int, prms *Parameters)</a></dd>
			
				
				<dd><a href="#CxIntOrd">func CxIntOrd(a, b, A, B []int, prms *Parameters)</a></dd>
			
				
				<dd><a href="#GenTrialSolutions">func GenTrialSolutions(sols []*Solution, prms *Parameters)</a></dd>
			
				
				<dd><a href="#GenerateCxEnds">func GenerateCxEnds(size, ncuts int, cuts []int) (ends []int)</a></dd>
			
				
				<dd><a href="#GetFeasible">func GetFeasible(sols []*Solution) (feasible []*Solution)</a></dd>
			
				
				<dd><a href="#GetParetoFront">func GetParetoFront(p, q int, all []*Solution, feasibleOnly bool) (fp, fq []float64, front []int)</a></dd>
			
				
				<dd><a href="#GetParetoFrontRes">func GetParetoFrontRes(p, q int, res [][]float64) (fp, fq []float64, front []int)</a></dd>
			
				
				<dd><a href="#GetResults">func GetResults(sols []*Solution, ovaOnly bool) (ova, oor [][]float64)</a></dd>
			
				
				<dd><a href="#MtFltDeb">func MtFltDeb(A []float64, prms *Parameters)</a></dd>
			
				
				<dd><a href="#MtInt">func MtInt(A []int, prms *Parameters)</a></dd>
			
				
				<dd><a href="#MtIntBin">func MtIntBin(A []int, prms *Parameters)</a></dd>
			
				
				<dd><a href="#MtIntOrd">func MtIntOrd(A []int, prms *Parameters)</a></dd>
			
				
				<dd><a href="#NewSolutions">func NewSolutions(nsol int, prms *Parameters) (res []*Solution)</a></dd>
			
				
				<dd><a href="#PlotFltFltContour">func PlotFltFltContour(fnkey string, opt *Optimiser, sols0 []*Solution, iFlt, jFlt, iOva int, cprms ContourParams, extra func(), equalAxes bool)</a></dd>
			
				
				<dd><a href="#PlotFltOva">func PlotFltOva(fnkey string, opt *Optimiser, sols0 []*Solution, iFlt, iOva, np int, ovaMult float64, fcn func(x float64) float64, extra func(), equalAxes bool)</a></dd>
			
				
				<dd><a href="#PlotOvaOvaPareto">func PlotOvaOvaPareto(fnkey string, opt *Optimiser, sols0 []*Solution, iOva, jOva int, extra func(), lims []float64, equalAxes bool)</a></dd>
			
				
				<dd><a href="#SortByBest">func SortByBest(s []*Solution)</a></dd>
			
				
				<dd><a href="#SortByOva">func SortByOva(s []*Solution, idxOva int)</a></dd>
			
				
				<dd><a href="#SortByTradeoff">func SortByTradeoff(s []*Solution)</a></dd>
			
				
				<dd><a href="#TexDocumentEnd">func TexDocumentEnd(buf *bytes.Buffer)</a></dd>
			
				
				<dd><a href="#TexDocumentStart">func TexDocumentStart() (buf *bytes.Buffer)</a></dd>
			
				
				<dd><a href="#TexPrmsReport">func TexPrmsReport(dirout, fnkey string, opts []*Optimiser, nRowPerTab int)</a></dd>
			
				
				<dd><a href="#TexPrmsTableEnd">func TexPrmsTableEnd(buf *bytes.Buffer)</a></dd>
			
				
				<dd><a href="#TexPrmsTableItem">func TexPrmsTableItem(o *Optimiser, buf *bytes.Buffer, problem int)</a></dd>
			
				
				<dd><a href="#TexPrmsTableStart">func TexPrmsTableStart(buf *bytes.Buffer)</a></dd>
			
				
				<dd><a href="#TexSingleObjReport">func TexSingleObjReport(dirout, fnkey string, ntrials, nRowPerTab int, opts []*Optimiser, frefs []float64, nDigitsF, nDigitsX, nDigitsHist []int)</a></dd>
			
				
				<dd><a href="#TexSingleObjTableEnd">func TexSingleObjTableEnd(buf *bytes.Buffer)</a></dd>
			
				
				<dd><a href="#TexSingleObjTableItem">func TexSingleObjTableItem(o *Optimiser, buf *bytes.Buffer, problem int, fref float64, nDigitsF, nDigitsX, nDigitsHist int)</a></dd>
			
				
				<dd><a href="#TexSingleObjTableStart">func TexSingleObjTableStart(buf *bytes.Buffer, ntrials int)</a></dd>
			
				
				<dd><a href="#TexWrite">func TexWrite(dirout, fnkey string, buf *bytes.Buffer, dorun bool)</a></dd>
			
			
				
				<dd><a href="#ContourParams">type ContourParams</a></dd>
				
				
			
				
				<dd><a href="#CxFlt_t">type CxFlt_t</a></dd>
				
				
			
				
				<dd><a href="#CxInt_t">type CxInt_t</a></dd>
				
				
			
				
				<dd><a href="#Generator_t">type Generator_t</a></dd>
				
				
			
				
				<dd><a href="#Group">type Group</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Group.Init">func (o *Group) Init(cpu, ncpu int, solutions, futuresols []*Solution, prms *Parameters)</a></dd>
				
			
				
				<dd><a href="#Metrics">type Metrics</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Metrics.Compute">func (o *Metrics) Compute(sols []*Solution) (nfronts int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Metrics.Init">func (o *Metrics) Init(nsol int, prms *Parameters)</a></dd>
				
			
				
				<dd><a href="#MinProb_t">type MinProb_t</a></dd>
				
				
			
				
				<dd><a href="#MtFlt_t">type MtFlt_t</a></dd>
				
				
			
				
				<dd><a href="#MtInt_t">type MtInt_t</a></dd>
				
				
			
				
				<dd><a href="#ObjFunc_t">type ObjFunc_t</a></dd>
				
				
			
				
				<dd><a href="#Optimiser">type Optimiser</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Optimiser.GetSolutionsCopy">func (o *Optimiser) GetSolutionsCopy() (res []*Solution)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Optimiser.Init">func (o *Optimiser) Init(gen Generator_t, obj ObjFunc_t, fcn MinProb_t, nf, ng, nh int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Optimiser.PlotAddFltFlt">func (o *Optimiser) PlotAddFltFlt(iFlt, jFlt int, sols []*Solution, fmt plt.Fmt, emptyMarker bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Optimiser.PlotAddFltOva">func (o *Optimiser) PlotAddFltOva(iFlt, iOva int, sols []*Solution, ovaMult float64, fmt plt.Fmt, emptyMarker bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Optimiser.PlotAddOvaOva">func (o *Optimiser) PlotAddOvaOva(iOva, jOva int, sols []*Solution, fmt plt.Fmt, emptyMarker bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Optimiser.PlotAddParetoFront">func (o *Optimiser) PlotAddParetoFront(iOva, jOva int, sols []*Solution, fmt plt.Fmt, emptyMarker bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Optimiser.PlotContour">func (o *Optimiser) PlotContour(iFlt, jFlt, iOva int, prms ContourParams)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Optimiser.RunMany">func (o *Optimiser) RunMany()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Optimiser.Solve">func (o *Optimiser) Solve()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Optimiser.StatMinProb">func (o *Optimiser) StatMinProb(idxF, hlen int, Fref float64, verbose bool) (fmin, fave, fmax, fdev float64, F []float64)</a></dd>
				
			
				
				<dd><a href="#Parameters">type Parameters</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Parameters.CalcDerived">func (o *Parameters) CalcDerived()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Parameters.Default">func (o *Parameters) Default()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Parameters.EnforceRange">func (o *Parameters) EnforceRange(i int, x float64) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Parameters.LogParams">func (o *Parameters) LogParams() (l string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Parameters.Read">func (o *Parameters) Read(filenamepath string)</a></dd>
				
			
				
				<dd><a href="#Solution">type Solution</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSolution">func NewSolution(id, nsol int, prms *Parameters) (o *Solution)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Solution.Compare">func (A *Solution) Compare(B *Solution) (A_dominates, B_dominates bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Solution.CopyInto">func (A *Solution) CopyInto(B *Solution)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Solution.Distance">func (A *Solution) Distance(B *Solution, fmin, fmax []float64, imin, imax []int) (dist float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Solution.Feasible">func (o *Solution) Feasible() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Solution.Fight">func (A *Solution) Fight(B *Solution) (A_wins bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Solution.GetCopyResults">func (o *Solution) GetCopyResults() (xFlt []float64, xInt []int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Solution.OvaDistance">func (A *Solution) OvaDistance(B *Solution, omin, omax []float64) (dist float64)</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/github.com/cpmech/goga/defs.go">defs.go</a>
			
				<a href="/src/github.com/cpmech/goga/generators.go">generators.go</a>
			
				<a href="/src/github.com/cpmech/goga/group.go">group.go</a>
			
				<a href="/src/github.com/cpmech/goga/intoperators.go">intoperators.go</a>
			
				<a href="/src/github.com/cpmech/goga/metrics.go">metrics.go</a>
			
				<a href="/src/github.com/cpmech/goga/operators.go">operators.go</a>
			
				<a href="/src/github.com/cpmech/goga/optimiser.go">optimiser.go</a>
			
				<a href="/src/github.com/cpmech/goga/params.go">params.go</a>
			
				<a href="/src/github.com/cpmech/goga/plotting.go">plotting.go</a>
			
				<a href="/src/github.com/cpmech/goga/postproc.go">postproc.go</a>
			
				<a href="/src/github.com/cpmech/goga/report.go">report.go</a>
			
				<a href="/src/github.com/cpmech/goga/solution.go">solution.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const (
    <span id="INF">INF</span> = 1e+30 <span class="comment">// infinite distance</span>
)</pre>
				<p>
constants
</p>

			
		
		
		
			
			
			<h2 id="CxFltDE">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=876:952#L30">CxFltDE</a></h2>
			<pre>func CxFltDE(a, b, A, B, x0, x1, x2, y0, y1, y2 []<a href="/pkg/builtin/#float64">float64</a>, prms *<a href="#Parameters">Parameters</a>)</pre>
			<p>
CxFltDE implements the differential-evolution crossover
</p>

			
			

		
			
			
			<h2 id="CxInt">func <a href="https://github.com/cpmech/goga/blob/master//intoperators.go?s=653:699#L16">CxInt</a></h2>
			<pre>func CxInt(a, b, A, B []<a href="/pkg/builtin/#int">int</a>, prms *<a href="#Parameters">Parameters</a>)</pre>
			<p>
CxInt performs the crossover of genetic data from A and B
</p>
<pre>Output:
 a and b -- offspring
Example:
       0 1 2 3 4 5 6 7
   A = a b c d e f g h    size = 8
   B = * . . . . * * *    cuts = [1, 5]
        ↑       ↑     ↑   ends = [1, 5, 8]
        1       5     8
   a = a . . . . f g h
   b = * b c d e * * *
</pre>

			
			

		
			
			
			<h2 id="CxIntOrd">func <a href="https://github.com/cpmech/goga/blob/master//intoperators.go?s=2560:2609#L70">CxIntOrd</a></h2>
			<pre>func CxIntOrd(a, b, A, B []<a href="/pkg/builtin/#int">int</a>, prms *<a href="#Parameters">Parameters</a>)</pre>
			<p>
CxIntOrd performs the crossover in a pair of individuals with integer numbers
that correspond to a ordered sequence, e.g. for traveling salesman problem
</p>
<pre>Output:
  a and b -- offspring chromosomes
Note: using OX1 method explained in [1] (proposed in [2])
References:
 [1] Larrañaga P, Kuijpers CMH, Murga RH, Inza I and Dizdarevic S. Genetic Algorithms for the
     Travelling Salesman Problem: A Review of Representations and Operators. Artificial
     Intelligence Review, 13:129-170; 1999. doi:10.1023/A:1006529012972
 [2] Davis L. Applying Adaptive Algorithms to Epistatic Domains. Proceedings of International
     Joint Conference on Artificial Intelligence, 162-164; 1985.
Example:
 data:
       0 1   2 3 4   5 6 7
   A = a b | c d e | f g h        size = 8
   B = b d | f h g | e c a        cuts = [2, 5]
           ↑       ↑       ↑      ends = [2, 5, 8]
           2       5       8
 first step: copy subtours
   a = . . | f h g | . . .
   b = . . | c d e | . . .
 second step: copy unique from subtour&#39;s end, position 5
             start adding here
                     ↓                           5 6 7   0 1   2 3 4
   a = d e | f h g | a b c         get from A: | f̶ g̶ h̶ | a b | c d e
   b = h g | c d e | a b f         get from B: | e̶ c̶ a | b d̶ | f h g
</pre>

			
			

		
			
			
			<h2 id="GenTrialSolutions">func <a href="https://github.com/cpmech/goga/blob/master//generators.go?s=279:337#L1">GenTrialSolutions</a></h2>
			<pre>func GenTrialSolutions(sols []*<a href="#Solution">Solution</a>, prms *<a href="#Parameters">Parameters</a>)</pre>
			<p>
GenTrialSolutions generates (initial) trial solutions
</p>

			
			

		
			
			
			<h2 id="GenerateCxEnds">func <a href="https://github.com/cpmech/goga/blob/master//intoperators.go?s=6853:6914#L247">GenerateCxEnds</a></h2>
			<pre>func GenerateCxEnds(size, ncuts <a href="/pkg/builtin/#int">int</a>, cuts []<a href="/pkg/builtin/#int">int</a>) (ends []<a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
GenerateCxEnds randomly computes the end positions of cuts in chromosomes
</p>
<pre>Input:
 size  -- size of chromosome
 ncuts -- number of cuts to be used, unless cuts != nil
 cuts  -- cut positions. can be nil =&gt; use ncuts instead
Output:
 ends -- end positions where the last one equals size
Example:
      0 1 2 3 4 5 6 7
  A = a b c d e f g h    size = 8
       ↑       ↑     ↑   cuts = [1, 5]
       1       5     8   ends = [1, 5, 8]
</pre>

			
			

		
			
			
			<h2 id="GetFeasible">func <a href="https://github.com/cpmech/goga/blob/master//postproc.go?s=1476:1533#L47">GetFeasible</a></h2>
			<pre>func GetFeasible(sols []*<a href="#Solution">Solution</a>) (feasible []*<a href="#Solution">Solution</a>)</pre>
			<p>
GetFeasible returns all feasible solutions
</p>

			
			

		
			
			
			<h2 id="GetParetoFront">func <a href="https://github.com/cpmech/goga/blob/master//postproc.go?s=2669:2766#L98">GetParetoFront</a></h2>
			<pre>func GetParetoFront(p, q <a href="/pkg/builtin/#int">int</a>, all []*<a href="#Solution">Solution</a>, feasibleOnly <a href="/pkg/builtin/#bool">bool</a>) (fp, fq []<a href="/pkg/builtin/#float64">float64</a>, front []<a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
GetParetoFront returns Pareto front
</p>

			
			

		
			
			
			<h2 id="GetParetoFrontRes">func <a href="https://github.com/cpmech/goga/blob/master//postproc.go?s=2364:2445#L86">GetParetoFrontRes</a></h2>
			<pre>func GetParetoFrontRes(p, q <a href="/pkg/builtin/#int">int</a>, res [][]<a href="/pkg/builtin/#float64">float64</a>) (fp, fq []<a href="/pkg/builtin/#float64">float64</a>, front []<a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
GetParetoFrontRes returns results on Pareto front
</p>
<pre>Input:
 p   -- first column in res
 q   -- second column in res
 res -- e.g. can be either ova or oor
</pre>

			
			

		
			
			
			<h2 id="GetResults">func <a href="https://github.com/cpmech/goga/blob/master//postproc.go?s=1779:1849#L60">GetResults</a></h2>
			<pre>func GetResults(sols []*<a href="#Solution">Solution</a>, ovaOnly <a href="/pkg/builtin/#bool">bool</a>) (ova, oor [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
GetResults returns all ovas and oors
</p>
<pre>Output:
 ova -- [nsol][nova] objective values
 oor -- [nsol][noor] out-of-range values
</pre>

			
			

		
			
			
			<h2 id="MtFltDeb">func <a href="https://github.com/cpmech/goga/blob/master//operators.go?s=1288:1332#L38">MtFltDeb</a></h2>
			<pre>func MtFltDeb(A []<a href="/pkg/builtin/#float64">float64</a>, prms *<a href="#Parameters">Parameters</a>)</pre>
			<p>
MtFltDeb implements Deb&#39;s parameter-based mutation operator
</p>
<pre>[1] Deb K and Tiwari S (2008) Omni-optimizer: A generic evolutionary algorithm for single
    and multi-objective optimization. European Journal of Operational Research, 185:1062-1087.
</pre>

			
			

		
			
			
			<h2 id="MtInt">func <a href="https://github.com/cpmech/goga/blob/master//intoperators.go?s=3666:3703#L123">MtInt</a></h2>
			<pre>func MtInt(A []<a href="/pkg/builtin/#int">int</a>, prms *<a href="#Parameters">Parameters</a>)</pre>
			<p>
MtInt performs the mutation of genetic data from A
</p>
<pre>Output: modified individual &#39;A&#39;
</pre>

			
			

		
			
			
			<h2 id="MtIntBin">func <a href="https://github.com/cpmech/goga/blob/master//intoperators.go?s=4077:4117#L143">MtIntBin</a></h2>
			<pre>func MtIntBin(A []<a href="/pkg/builtin/#int">int</a>, prms *<a href="#Parameters">Parameters</a>)</pre>
			<p>
MtIntBin performs the mutation of a binary chromosome
</p>
<pre>Output: modified individual &#39;A&#39;
</pre>

			
			

		
			
			
			<h2 id="MtIntOrd">func <a href="https://github.com/cpmech/goga/blob/master//intoperators.go?s=5413:5453#L183">MtIntOrd</a></h2>
			<pre>func MtIntOrd(A []<a href="/pkg/builtin/#int">int</a>, prms *<a href="#Parameters">Parameters</a>)</pre>
			<p>
MtIntOrd performs the mutation of genetic data from a ordered list of integers A
</p>
<pre>Output: modified individual &#39;A&#39;
Note: using DM method as explained in [1] (citing [2])
References:
 [1] Larrañaga P, Kuijpers CMH, Murga RH, Inza I and Dizdarevic S. Genetic Algorithms for the
     Travelling Salesman Problem: A Review of Representations and Operators. Artificial
     Intelligence Review, 13:129-170; 1999. doi:10.1023/A:1006529012972
 [2] Michalewicz Z. Genetic Algorithms + Data Structures = Evolution Programs. Berlin
     Heidelberg: Springer Verlag; 1992
     Joint Conference on Artificial Intelligence, 162-164; 1985.

DM displacement mutation method:
 Ex:
         0 1 2 3 4 5 6 7
     A = a b c d e f g h   s = 2
            ↑     ↑        t = 5
            2     5

     core = c d e  (subtour)  ncore = t - s = 5 - 2 = 3

              0 1 2 3 4
     remain = a b f g h  (remaining)  nrem = size - ncore = 8 - 3 = 5
                     ↑
                     4 = ins
</pre>

			
			

		
			
			
			<h2 id="NewSolutions">func <a href="https://github.com/cpmech/goga/blob/master//solution.go?s=1369:1432#L41">NewSolutions</a></h2>
			<pre>func NewSolutions(nsol <a href="/pkg/builtin/#int">int</a>, prms *<a href="#Parameters">Parameters</a>) (res []*<a href="#Solution">Solution</a>)</pre>
			<p>
NewSolutions allocates a number of Solutions
</p>

			
			

		
			
			
			<h2 id="PlotFltFltContour">func <a href="https://github.com/cpmech/goga/blob/master//plotting.go?s=5469:5613#L176">PlotFltFltContour</a></h2>
			<pre>func PlotFltFltContour(fnkey <a href="/pkg/builtin/#string">string</a>, opt *<a href="#Optimiser">Optimiser</a>, sols0 []*<a href="#Solution">Solution</a>, iFlt, jFlt, iOva <a href="/pkg/builtin/#int">int</a>, cprms <a href="#ContourParams">ContourParams</a>, extra func(), equalAxes <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
PlotFltFlt plots flt-flt contour
</p>

			
			

		
			
			
			<h2 id="PlotFltOva">func <a href="https://github.com/cpmech/goga/blob/master//plotting.go?s=4464:4624#L149">PlotFltOva</a></h2>
			<pre>func PlotFltOva(fnkey <a href="/pkg/builtin/#string">string</a>, opt *<a href="#Optimiser">Optimiser</a>, sols0 []*<a href="#Solution">Solution</a>, iFlt, iOva, np <a href="/pkg/builtin/#int">int</a>, ovaMult <a href="/pkg/builtin/#float64">float64</a>, fcn func(x <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a>, extra func(), equalAxes <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
PlotFltOva plots flt-ova points
</p>

			
			

		
			
			
			<h2 id="PlotOvaOvaPareto">func <a href="https://github.com/cpmech/goga/blob/master//plotting.go?s=6446:6578#L202">PlotOvaOvaPareto</a></h2>
			<pre>func PlotOvaOvaPareto(fnkey <a href="/pkg/builtin/#string">string</a>, opt *<a href="#Optimiser">Optimiser</a>, sols0 []*<a href="#Solution">Solution</a>, iOva, jOva <a href="/pkg/builtin/#int">int</a>, extra func(), lims []<a href="/pkg/builtin/#float64">float64</a>, equalAxes <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
PlotOvaOvaPareto plots ova-ova Pareto values
</p>

			
			

		
			
			
			<h2 id="SortByBest">func <a href="https://github.com/cpmech/goga/blob/master//solution.go?s=6271:6301#L245">SortByBest</a></h2>
			<pre>func SortByBest(s []*<a href="#Solution">Solution</a>)</pre>
			<p>
SortByBest sorts slice of solutions with best solutions first
</p>

			
			

		
			
			
			<h2 id="SortByOva">func <a href="https://github.com/cpmech/goga/blob/master//solution.go?s=5964:6005#L231">SortByOva</a></h2>
			<pre>func SortByOva(s []*<a href="#Solution">Solution</a>, idxOva <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
SortByOva sorts slice of solutions in ascending order of ova
</p>

			
			

		
			
			
			<h2 id="SortByTradeoff">func <a href="https://github.com/cpmech/goga/blob/master//solution.go?s=6340:6374#L250">SortByTradeoff</a></h2>
			<pre>func SortByTradeoff(s []*<a href="#Solution">Solution</a>)</pre>
			<p>
TODO
</p>

			
			

		
			
			
			<h2 id="TexDocumentEnd">func <a href="https://github.com/cpmech/goga/blob/master//report.go?s=745:783#L24">TexDocumentEnd</a></h2>
			<pre>func TexDocumentEnd(buf *<a href="/pkg/bytes/">bytes</a>.<a href="/pkg/bytes/#Buffer">Buffer</a>)</pre>
			<p>
TexDocumentEnd ends TeX document
</p>

			
			

		
			
			
			<h2 id="TexDocumentStart">func <a href="https://github.com/cpmech/goga/blob/master//report.go?s=438:481#L8">TexDocumentStart</a></h2>
			<pre>func TexDocumentStart() (buf *<a href="/pkg/bytes/">bytes</a>.<a href="/pkg/bytes/#Buffer">Buffer</a>)</pre>
			<p>
TexDocumentStart starts TeX document
</p>

			
			

		
			
			
			<h2 id="TexPrmsReport">func <a href="https://github.com/cpmech/goga/blob/master//report.go?s=2093:2168#L68">TexPrmsReport</a></h2>
			<pre>func TexPrmsReport(dirout, fnkey <a href="/pkg/builtin/#string">string</a>, opts []*<a href="#Optimiser">Optimiser</a>, nRowPerTab <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
TexPrmsReport generates TeX report with parameters
</p>
<pre>nRowPerTab -- number of rows per table
</pre>

			
			

		
			
			
			<h2 id="TexPrmsTableEnd">func <a href="https://github.com/cpmech/goga/blob/master//report.go?s=1665:1704#L55">TexPrmsTableEnd</a></h2>
			<pre>func TexPrmsTableEnd(buf *<a href="/pkg/bytes/">bytes</a>.<a href="/pkg/bytes/#Buffer">Buffer</a>)</pre>
			<p>
TexPrmsTableEnd ends table with parameters
</p>

			
			

		
			
			
			<h2 id="TexPrmsTableItem">func <a href="https://github.com/cpmech/goga/blob/master//report.go?s=1823:1890#L62">TexPrmsTableItem</a></h2>
			<pre>func TexPrmsTableItem(o *<a href="#Optimiser">Optimiser</a>, buf *<a href="/pkg/bytes/">bytes</a>.<a href="/pkg/bytes/#Buffer">Buffer</a>, problem <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
TexPrmsTableItem adds item to table with parameters
</p>

			
			

		
			
			
			<h2 id="TexPrmsTableStart">func <a href="https://github.com/cpmech/goga/blob/master//report.go?s=1387:1428#L45">TexPrmsTableStart</a></h2>
			<pre>func TexPrmsTableStart(buf *<a href="/pkg/bytes/">bytes</a>.<a href="/pkg/bytes/#Buffer">Buffer</a>)</pre>
			<p>
TexPrmsTableStart starts table with parameters
</p>

			
			

		
			
			
			<h2 id="TexSingleObjReport">func <a href="https://github.com/cpmech/goga/blob/master//report.go?s=4696:4841#L152">TexSingleObjReport</a></h2>
			<pre>func TexSingleObjReport(dirout, fnkey <a href="/pkg/builtin/#string">string</a>, ntrials, nRowPerTab <a href="/pkg/builtin/#int">int</a>, opts []*<a href="#Optimiser">Optimiser</a>, frefs []<a href="/pkg/builtin/#float64">float64</a>, nDigitsF, nDigitsX, nDigitsHist []<a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
TexSingleObjReport produces Single-Objective table TeX report
</p>
<pre>nRowPerTab -- number of rows per table
</pre>

			
			

		
			
			
			<h2 id="TexSingleObjTableEnd">func <a href="https://github.com/cpmech/goga/blob/master//report.go?s=3214:3258#L105">TexSingleObjTableEnd</a></h2>
			<pre>func TexSingleObjTableEnd(buf *<a href="/pkg/bytes/">bytes</a>.<a href="/pkg/bytes/#Buffer">Buffer</a>)</pre>
			<p>
TexSingleObjTableEnd ends table for single-objective optimisation results with ntrials
</p>

			
			

		
			
			
			<h2 id="TexSingleObjTableItem">func <a href="https://github.com/cpmech/goga/blob/master//report.go?s=3426:3549#L112">TexSingleObjTableItem</a></h2>
			<pre>func TexSingleObjTableItem(o *<a href="#Optimiser">Optimiser</a>, buf *<a href="/pkg/bytes/">bytes</a>.<a href="/pkg/bytes/#Buffer">Buffer</a>, problem <a href="/pkg/builtin/#int">int</a>, fref <a href="/pkg/builtin/#float64">float64</a>, nDigitsF, nDigitsX, nDigitsHist <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
TexSingleObjTableItem adds item to table for single-objective optimisation results with ntrials
</p>

			
			

		
			
			
			<h2 id="TexSingleObjTableStart">func <a href="https://github.com/cpmech/goga/blob/master//report.go?s=2854:2913#L95">TexSingleObjTableStart</a></h2>
			<pre>func TexSingleObjTableStart(buf *<a href="/pkg/bytes/">bytes</a>.<a href="/pkg/bytes/#Buffer">Buffer</a>, ntrials <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
TexSingleObjTableStart starts table for single-objective optimisation results with ntrials
</p>

			
			

		
			
			
			<h2 id="TexWrite">func <a href="https://github.com/cpmech/goga/blob/master//report.go?s=865:931#L30">TexWrite</a></h2>
			<pre>func TexWrite(dirout, fnkey <a href="/pkg/builtin/#string">string</a>, buf *<a href="/pkg/bytes/">bytes</a>.<a href="/pkg/bytes/#Buffer">Buffer</a>, dorun <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
TexWrite writes and compiles TeX document
</p>

			
			

		
		
			
			
			<h2 id="ContourParams">type <a href="https://github.com/cpmech/goga/blob/master//plotting.go?s=337:788#L4">ContourParams</a></h2>
			<pre>type ContourParams struct {
    Npts    <a href="/pkg/builtin/#int">int</a>       <span class="comment">// number of points for contour</span>
    CmapIdx <a href="/pkg/builtin/#int">int</a>       <span class="comment">// colormap index</span>
    Csimple <a href="/pkg/builtin/#bool">bool</a>      <span class="comment">// simple contour</span>
    AxEqual <a href="/pkg/builtin/#bool">bool</a>      <span class="comment">// axes-equal</span>
    Lwg     <a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// linewidth for g functions</span>
    Lwh     <a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// linewidth for h functions</span>
    Args    <a href="/pkg/builtin/#string">string</a>    <span class="comment">// extra arguments for plot</span>
    Extra   func()    <span class="comment">// extra function</span>
    Xrange  []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// to override x-range</span>
    Yrange  []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// to override y-range</span>
}</pre>
			<p>
ContourParams holds parameters to plot contours
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="CxFlt_t">type <a href="https://github.com/cpmech/goga/blob/master//defs.go?s=647:728#L12">CxFlt_t</a></h2>
			<pre>type CxFlt_t func(a, b, A, B, x0, x1, x2, y0, y1, y2 []<a href="/pkg/builtin/#float64">float64</a>, prms *<a href="#Parameters">Parameters</a>)</pre>
			<p>
CxFlt_t defines crossover function for floats
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="CxInt_t">type <a href="https://github.com/cpmech/goga/blob/master//defs.go?s=777:830#L15">CxInt_t</a></h2>
			<pre>type CxInt_t func(a, b, A, B []<a href="/pkg/builtin/#int">int</a>, prms *<a href="#Parameters">Parameters</a>)</pre>
			<p>
CxInt_t defines crossover function for ints
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Generator_t">type <a href="https://github.com/cpmech/goga/blob/master//defs.go?s=312:369#L3">Generator_t</a></h2>
			<pre>type Generator_t func(sols []*<a href="#Solution">Solution</a>, prms *<a href="#Parameters">Parameters</a>)</pre>
			<p>
Generator_t defines callback function to generate trial solutions
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Group">type <a href="https://github.com/cpmech/goga/blob/master//group.go?s=295:795#L3">Group</a></h2>
			<pre>type Group struct {
    Ncur    <a href="/pkg/builtin/#int">int</a>           <span class="comment">// number of current solutions == len(All) / 2</span>
    All     []*<a href="#Solution">Solution</a>   <span class="comment">// current and future solutions =&gt; view to Solutions and FutureSols</span>
    Indices []<a href="/pkg/builtin/#int">int</a>         <span class="comment">// indices of current solutions</span>
    Pairs   [][]<a href="/pkg/builtin/#int">int</a>       <span class="comment">// randomly selected pairs from Indices</span>
    Triples [][]<a href="/pkg/builtin/#int">int</a>       <span class="comment">// randomly selected tuples from Indices</span>
    Metrics *<a href="#Metrics">Metrics</a>      <span class="comment">// metrics</span>
    Mdist   [][]<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// match distances with triples</span>
    Match   <a href="/pkg/github.com/cpmech/gosl/graph/">graph</a>.<a href="/pkg/github.com/cpmech/gosl/graph/#Munkres">Munkres</a> <span class="comment">// matches with triples</span>
}</pre>
			<p>
Group holds a group of solutions
</p>


			

			

			
			
			

			

			
				
				<h3 id="Group.Init">func (*Group) <a href="https://github.com/cpmech/goga/blob/master//group.go?s=823:911#L15">Init</a></h3>
				<pre>func (o *<a href="#Group">Group</a>) Init(cpu, ncpu <a href="/pkg/builtin/#int">int</a>, solutions, futuresols []*<a href="#Solution">Solution</a>, prms *<a href="#Parameters">Parameters</a>)</pre>
				<p>
Init initialises group
</p>

				
				
				
			
		
			
			
			<h2 id="Metrics">type <a href="https://github.com/cpmech/goga/blob/master//metrics.go?s=331:723#L5">Metrics</a></h2>
			<pre>type Metrics struct {
    Omin   []<a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// current min ova</span>
    Omax   []<a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// current max ova</span>
    Fmin   []<a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// current min float</span>
    Fmax   []<a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// current max float</span>
    Imin   []<a href="/pkg/builtin/#int">int</a>         <span class="comment">// current min int</span>
    Imax   []<a href="/pkg/builtin/#int">int</a>         <span class="comment">// current max int</span>
    Fsizes []<a href="/pkg/builtin/#int">int</a>         <span class="comment">// front sizes</span>
    Fronts [][]*<a href="#Solution">Solution</a> <span class="comment">// non-dominated fronts</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Metrics holds metric data such as non-dominated Pareto fronts
</p>


			

			

			
			
			

			

			
				
				<h3 id="Metrics.Compute">func (*Metrics) <a href="https://github.com/cpmech/goga/blob/master//metrics.go?s=1268:1325#L34">Compute</a></h3>
				<pre>func (o *<a href="#Metrics">Metrics</a>) Compute(sols []*<a href="#Solution">Solution</a>) (nfronts <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Compute computes limits, find non-dominated Pareto fronts, and compute crowd distances
</p>

				
				
				
			
				
				<h3 id="Metrics.Init">func (*Metrics) <a href="https://github.com/cpmech/goga/blob/master//metrics.go?s=753:803#L18">Init</a></h3>
				<pre>func (o *<a href="#Metrics">Metrics</a>) Init(nsol <a href="/pkg/builtin/#int">int</a>, prms *<a href="#Parameters">Parameters</a>)</pre>
				<p>
Init initialises Metrics
</p>

				
				
				
			
		
			
			
			<h2 id="MinProb_t">type <a href="https://github.com/cpmech/goga/blob/master//defs.go?s=536:596#L9">MinProb_t</a></h2>
			<pre>type MinProb_t func(f, g, h, x []<a href="/pkg/builtin/#float64">float64</a>, ξ []<a href="/pkg/builtin/#int">int</a>, cpu <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
MinProb_t defines objective functon for specialised minimisation problem
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="MtFlt_t">type <a href="https://github.com/cpmech/goga/blob/master//defs.go?s=880:928#L18">MtFlt_t</a></h2>
			<pre>type MtFlt_t func(a []<a href="/pkg/builtin/#float64">float64</a>, prms *<a href="#Parameters">Parameters</a>)</pre>
			<p>
MtFlt_t defines mutation function for floats
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="MtInt_t">type <a href="https://github.com/cpmech/goga/blob/master//defs.go?s=976:1020#L21">MtInt_t</a></h2>
			<pre>type MtInt_t func(a []<a href="/pkg/builtin/#int">int</a>, prms *<a href="#Parameters">Parameters</a>)</pre>
			<p>
MtInt_t defines mutation function for ints
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="ObjFunc_t">type <a href="https://github.com/cpmech/goga/blob/master//defs.go?s=415:458#L6">ObjFunc_t</a></h2>
			<pre>type ObjFunc_t func(sol *<a href="#Solution">Solution</a>, cpu <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
ObjFunc_t defines the objective fluction
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Optimiser">type <a href="https://github.com/cpmech/goga/blob/master//optimiser.go?s=840:2037#L25">Optimiser</a></h2>
			<pre>type Optimiser struct {

    <span class="comment">// input</span>
    <a href="#Parameters">Parameters</a>           <span class="comment">// input parameters</span>
    ObjFunc    <a href="#ObjFunc_t">ObjFunc_t</a> <span class="comment">// objective function</span>
    MinProb    <a href="#MinProb_t">MinProb_t</a> <span class="comment">// minimisation problem function</span>
    CxFlt      <a href="#CxFlt_t">CxFlt_t</a>   <span class="comment">// crossover function for floats</span>
    CxInt      <a href="#CxInt_t">CxInt_t</a>   <span class="comment">// crossover function for ints</span>
    MtFlt      <a href="#MtFlt_t">MtFlt_t</a>   <span class="comment">// mutation function for floats</span>
    MtInt      <a href="#MtInt_t">MtInt_t</a>   <span class="comment">// mutation function for ints</span>

    <span class="comment">// essential</span>
    Generator  <a href="#Generator_t">Generator_t</a> <span class="comment">// generate solutions</span>
    Solutions  []*<a href="#Solution">Solution</a> <span class="comment">// current solutions</span>
    FutureSols []*<a href="#Solution">Solution</a> <span class="comment">// future solutions</span>
    Groups     []*<a href="#Group">Group</a>    <span class="comment">// [cpu] competitors per CPU. pointers to current and future solutions</span>
    Metrics    *<a href="#Metrics">Metrics</a>    <span class="comment">// metrics</span>

    <span class="comment">// auxiliary</span>
    Nf, Ng, Nh <a href="/pkg/builtin/#int">int</a>         <span class="comment">// number of f, g, h functions</span>
    F, G, H    [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [cpu] temporary</span>

    <span class="comment">// stat</span>
    Nfeval   <a href="/pkg/builtin/#int">int</a>         <span class="comment">// number of function evaluations</span>
    XfltBest [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// best results after RunMany</span>
    XintBest [][]<a href="/pkg/builtin/#int">int</a>     <span class="comment">// best results after RunMany</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Optimiser solves optimisation problems:
</p>
<pre>Solve:
 min  {Ova[0](x), Ova[1](x), ...} objective values
  x
 s.t. Oor[0](x) = 0
      Oor[1](x) = 0  out-of-range values
</pre>
<p>
A specialised version is also available
</p>
<pre>Solve:
  min  {f0(x), f1(x), f2(x), ...}  nf functions
   x   g0(x) ≥ 0
       g1(x) ≥ 0  ng inequalities
  s.t. h0(x) = 0
       h1(x) = 0  nh equalities

x = xFlt  or  x = xInt   or  x = {xFlt, Xint}
</pre>


			

			

			
			
			

			

			
				
				<h3 id="Optimiser.GetSolutionsCopy">func (*Optimiser) <a href="https://github.com/cpmech/goga/blob/master//optimiser.go?s=3831:3887#L126">GetSolutionsCopy</a></h3>
				<pre>func (o *<a href="#Optimiser">Optimiser</a>) GetSolutionsCopy() (res []*<a href="#Solution">Solution</a>)</pre>
				<p>
GetSolutionsCopy returns a copy of Solutions
</p>

				
				
				
			
				
				<h3 id="Optimiser.Init">func (*Optimiser) <a href="https://github.com/cpmech/goga/blob/master//optimiser.go?s=2143:2230#L59">Init</a></h3>
				<pre>func (o *<a href="#Optimiser">Optimiser</a>) Init(gen <a href="#Generator_t">Generator_t</a>, obj <a href="#ObjFunc_t">ObjFunc_t</a>, fcn <a href="#MinProb_t">MinProb_t</a>, nf, ng, nh <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Initialises continues initialisation by generating individuals
</p>
<pre>Optional: fcn XOR obj, nf, ng, nh
</pre>

				
				
				
			
				
				<h3 id="Optimiser.PlotAddFltFlt">func (*Optimiser) <a href="https://github.com/cpmech/goga/blob/master//plotting.go?s=2677:2775#L97">PlotAddFltFlt</a></h3>
				<pre>func (o *<a href="#Optimiser">Optimiser</a>) PlotAddFltFlt(iFlt, jFlt <a href="/pkg/builtin/#int">int</a>, sols []*<a href="#Solution">Solution</a>, fmt <a href="/pkg/github.com/cpmech/gosl/plt/">plt</a>.<a href="/pkg/github.com/cpmech/gosl/plt/#Fmt">Fmt</a>, emptyMarker <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
PlotAddFltFlt adds flt-flt points to existent plot
</p>

				
				
				
			
				
				<h3 id="Optimiser.PlotAddFltOva">func (*Optimiser) <a href="https://github.com/cpmech/goga/blob/master//plotting.go?s=3147:3262#L111">PlotAddFltOva</a></h3>
				<pre>func (o *<a href="#Optimiser">Optimiser</a>) PlotAddFltOva(iFlt, iOva <a href="/pkg/builtin/#int">int</a>, sols []*<a href="#Solution">Solution</a>, ovaMult <a href="/pkg/builtin/#float64">float64</a>, fmt <a href="/pkg/github.com/cpmech/gosl/plt/">plt</a>.<a href="/pkg/github.com/cpmech/gosl/plt/#Fmt">Fmt</a>, emptyMarker <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
PlotAddFltOva adds flt-ova points to existent plot
</p>

				
				
				
			
				
				<h3 id="Optimiser.PlotAddOvaOva">func (*Optimiser) <a href="https://github.com/cpmech/goga/blob/master//plotting.go?s=3642:3740#L125">PlotAddOvaOva</a></h3>
				<pre>func (o *<a href="#Optimiser">Optimiser</a>) PlotAddOvaOva(iOva, jOva <a href="/pkg/builtin/#int">int</a>, sols []*<a href="#Solution">Solution</a>, fmt <a href="/pkg/github.com/cpmech/gosl/plt/">plt</a>.<a href="/pkg/github.com/cpmech/gosl/plt/#Fmt">Fmt</a>, emptyMarker <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
PlotAddOvaOva adds ova-ova points to existent plot
</p>

				
				
				
			
				
				<h3 id="Optimiser.PlotAddParetoFront">func (*Optimiser) <a href="https://github.com/cpmech/goga/blob/master//plotting.go?s=4104:4207#L139">PlotAddParetoFront</a></h3>
				<pre>func (o *<a href="#Optimiser">Optimiser</a>) PlotAddParetoFront(iOva, jOva <a href="/pkg/builtin/#int">int</a>, sols []*<a href="#Solution">Solution</a>, fmt <a href="/pkg/github.com/cpmech/gosl/plt/">plt</a>.<a href="/pkg/github.com/cpmech/gosl/plt/#Fmt">Fmt</a>, emptyMarker <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
PlotAddParetoFront highlights Pareto front
</p>

				
				
				
			
				
				<h3 id="Optimiser.PlotContour">func (*Optimiser) <a href="https://github.com/cpmech/goga/blob/master//plotting.go?s=819:892#L18">PlotContour</a></h3>
				<pre>func (o *<a href="#Optimiser">Optimiser</a>) PlotContour(iFlt, jFlt, iOva <a href="/pkg/builtin/#int">int</a>, prms <a href="#ContourParams">ContourParams</a>)</pre>
				<p>
PlotContour plots contour
</p>

				
				
				
			
				
				<h3 id="Optimiser.RunMany">func (*Optimiser) <a href="https://github.com/cpmech/goga/blob/master//optimiser.go?s=5390:5419#L199">RunMany</a></h3>
				<pre>func (o *<a href="#Optimiser">Optimiser</a>) RunMany()</pre>
				<p>
RunMany runs many trials in order to produce statistics
</p>

				
				
				
			
				
				<h3 id="Optimiser.Solve">func (*Optimiser) <a href="https://github.com/cpmech/goga/blob/master//optimiser.go?s=4052:4079#L135">Solve</a></h3>
				<pre>func (o *<a href="#Optimiser">Optimiser</a>) Solve()</pre>
				<p>
Solve solves optimisation problem
</p>

				
				
				
			
				
				<h3 id="Optimiser.StatMinProb">func (*Optimiser) <a href="https://github.com/cpmech/goga/blob/master//postproc.go?s=348:469#L4">StatMinProb</a></h3>
				<pre>func (o *<a href="#Optimiser">Optimiser</a>) StatMinProb(idxF, hlen <a href="/pkg/builtin/#int">int</a>, Fref <a href="/pkg/builtin/#float64">float64</a>, verbose <a href="/pkg/builtin/#bool">bool</a>) (fmin, fave, fmax, fdev <a href="/pkg/builtin/#float64">float64</a>, F []<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
StatMinProb prints statistical analysis when using MinProb
</p>

				
				
				
			
		
			
			
			<h2 id="Parameters">type <a href="https://github.com/cpmech/goga/blob/master//params.go?s=352:2313#L6">Parameters</a></h2>
			<pre>type Parameters struct {

    <span class="comment">// sizes</span>
    Nova <a href="/pkg/builtin/#int">int</a> <span class="comment">// number of objective values</span>
    Noor <a href="/pkg/builtin/#int">int</a> <span class="comment">// number of out-of-range values</span>
    Nsol <a href="/pkg/builtin/#int">int</a> <span class="comment">// total number of solutions</span>
    Ncpu <a href="/pkg/builtin/#int">int</a> <span class="comment">// number of cpus</span>

    <span class="comment">// time</span>
    Tf    <a href="/pkg/builtin/#int">int</a> <span class="comment">// final time</span>
    DtExc <a href="/pkg/builtin/#int">int</a> <span class="comment">// delta time for exchange</span>
    DtOut <a href="/pkg/builtin/#int">int</a> <span class="comment">// delta time for output</span>

    <span class="comment">// options</span>
    Pll        <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// parallel</span>
    Seed       <a href="/pkg/builtin/#int">int</a>     <span class="comment">// seed for random numbers generator</span>
    Latin      <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// use Latin Hypercube</span>
    LatinDup   <a href="/pkg/builtin/#int">int</a>     <span class="comment">// Latin Hypercube duplicates number</span>
    EpsMinProb <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// minimum value for &#39;h&#39; constraints</span>
    Verbose    <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// show messages</span>
    Problem    <a href="/pkg/builtin/#int">int</a>     <span class="comment">// problem index</span>
    GenAll     <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// generate all solutions together; i.e. not within each group/CPU</span>
    Ntrials    <a href="/pkg/builtin/#int">int</a>     <span class="comment">// run many trials</span>
    BinInt     <a href="/pkg/builtin/#int">int</a>     <span class="comment">// flag that integers represent binary numbers if BinInt &gt; 0; thus Nint=BinInt</span>
    ClearFlt   <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// clear flt if corresponding int is 0</span>
    ExcTour    <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// use exchange via tournament</span>
    ExcOne     <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// use exchange one randomly</span>
    ConvDova0  <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// Δova[0] to decide on convergence</span>

    <span class="comment">// differential evolution</span>
    DiffEvolC        <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// crossover probability</span>
    DiffEvolF        <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// vector length multiplier</span>
    DiffEvolPm       <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// mutation probability. use rotation otherwise</span>
    DiffEvolUseCmult <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// use C random multiplier</span>
    DiffEvolUseFmult <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// use F random multiplier</span>

    <span class="comment">// crossover and mutation</span>
    DebEtam <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// Deb&#39;s mutation parameters</span>
    PmFlt   <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// probability of mutation for floats</span>
    PmInt   <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// probability of mutation for ints</span>
    PcInt   <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// probability of crossover for ints</span>

    <span class="comment">// range</span>
    FltMin []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// minimum float allowed</span>
    FltMax []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// maximum float allowed</span>
    IntMin []<a href="/pkg/builtin/#int">int</a>     <span class="comment">// minimum int allowed</span>
    IntMax []<a href="/pkg/builtin/#int">int</a>     <span class="comment">// maximum int allowed</span>

    <span class="comment">// derived</span>
    Nflt   <a href="/pkg/builtin/#int">int</a>       <span class="comment">// number of floats</span>
    Nint   <a href="/pkg/builtin/#int">int</a>       <span class="comment">// number of integers</span>
    DelFlt []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// max float range</span>
    DelInt []<a href="/pkg/builtin/#int">int</a>     <span class="comment">// max int range</span>
}</pre>
			<p>
Parameters hold all configuration parameters
</p>


			

			

			
			
			

			

			
				
				<h3 id="Parameters.CalcDerived">func (*Parameters) <a href="https://github.com/cpmech/goga/blob/master//params.go?s=3393:3427#L120">CalcDerived</a></h3>
				<pre>func (o *<a href="#Parameters">Parameters</a>) CalcDerived()</pre>
				<p>
CalcDerived computes derived variables and checks consistency
</p>

				
				
				
			
				
				<h3 id="Parameters.Default">func (*Parameters) <a href="https://github.com/cpmech/goga/blob/master//params.go?s=2350:2380#L62">Default</a></h3>
				<pre>func (o *<a href="#Parameters">Parameters</a>) Default()</pre>
				<p>
Default sets default parameters
</p>

				
				
				
			
				
				<h3 id="Parameters.EnforceRange">func (*Parameters) <a href="https://github.com/cpmech/goga/blob/master//params.go?s=4745:4804#L183">EnforceRange</a></h3>
				<pre>func (o *<a href="#Parameters">Parameters</a>) EnforceRange(i <a href="/pkg/builtin/#int">int</a>, x <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
EnforceRange makes sure x is within given range
</p>

				
				
				
			
				
				<h3 id="Parameters.LogParams">func (*Parameters) <a href="https://github.com/cpmech/goga/blob/master//params.go?s=4963:5006#L194">LogParams</a></h3>
				<pre>func (o *<a href="#Parameters">Parameters</a>) LogParams() (l <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
LogParams returns a log with current parameters
</p>

				
				
				
			
				
				<h3 id="Parameters.Read">func (*Parameters) <a href="https://github.com/cpmech/goga/blob/master//params.go?s=3025:3071#L106">Read</a></h3>
				<pre>func (o *<a href="#Parameters">Parameters</a>) Read(filenamepath <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
Read reads configuration parameters from JSON file
</p>

				
				
				
			
		
			
			
			<h2 id="Solution">type <a href="https://github.com/cpmech/goga/blob/master//solution.go?s=338:979#L7">Solution</a></h2>
			<pre>type Solution struct {
    Id  <a href="/pkg/builtin/#int">int</a>       <span class="comment">// identifier</span>
    Ova []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// objective values</span>
    Oor []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// out-of-range values</span>
    Flt []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// floats</span>
    Int []<a href="/pkg/builtin/#int">int</a>     <span class="comment">// ints</span>

    <span class="comment">// metrics</span>
    WinOver   []*<a href="#Solution">Solution</a> <span class="comment">// solutions dominated by this solution</span>
    Nwins     <a href="/pkg/builtin/#int">int</a>         <span class="comment">// number of wins =&gt; current len(WinOver)</span>
    Nlosses   <a href="/pkg/builtin/#int">int</a>         <span class="comment">// number of solutions dominating this solution</span>
    FrontId   <a href="/pkg/builtin/#int">int</a>         <span class="comment">// Pareto front rank</span>
    DistCrowd <a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// crowd distance</span>
    DistNeigh <a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// closest neighbour distance</span>
    Closest   *<a href="#Solution">Solution</a>   <span class="comment">// closest neighbour</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Solution holds solution values
</p>


			

			

			
			
			

			
				
				<h3 id="NewSolution">func <a href="https://github.com/cpmech/goga/blob/master//solution.go?s=1019:1081#L28">NewSolution</a></h3>
				<pre>func NewSolution(id, nsol <a href="/pkg/builtin/#int">int</a>, prms *<a href="#Parameters">Parameters</a>) (o *<a href="#Solution">Solution</a>)</pre>
				<p>
NewSolution allocates new Solution
</p>

				
				
			

			
				
				<h3 id="Solution.Compare">func (*Solution) <a href="https://github.com/cpmech/goga/blob/master//solution.go?s=2828:2899#L102">Compare</a></h3>
				<pre>func (A *<a href="#Solution">Solution</a>) Compare(B *<a href="#Solution">Solution</a>) (A_dominates, B_dominates <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Compare compares two solutions
</p>

				
				
				
			
				
				<h3 id="Solution.CopyInto">func (*Solution) <a href="https://github.com/cpmech/goga/blob/master//solution.go?s=1767:1807#L60">CopyInto</a></h3>
				<pre>func (A *<a href="#Solution">Solution</a>) CopyInto(B *<a href="#Solution">Solution</a>)</pre>
				<p>
CopyInto copies essential data into B
</p>

				
				
				
			
				
				<h3 id="Solution.Distance">func (*Solution) <a href="https://github.com/cpmech/goga/blob/master//solution.go?s=1963:2058#L69">Distance</a></h3>
				<pre>func (A *<a href="#Solution">Solution</a>) Distance(B *<a href="#Solution">Solution</a>, fmin, fmax []<a href="/pkg/builtin/#float64">float64</a>, imin, imax []<a href="/pkg/builtin/#int">int</a>) (dist <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Distance computes (genotype) distance between A and B
</p>

				
				
				
			
				
				<h3 id="Solution.Feasible">func (*Solution) <a href="https://github.com/cpmech/goga/blob/master//solution.go?s=1606:1640#L50">Feasible</a></h3>
				<pre>func (o *<a href="#Solution">Solution</a>) Feasible() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Feasible tells whether this solution is feasible or not
</p>

				
				
				
			
				
				<h3 id="Solution.Fight">func (*Solution) <a href="https://github.com/cpmech/goga/blob/master//solution.go?s=3661:3712#L140">Fight</a></h3>
				<pre>func (A *<a href="#Solution">Solution</a>) Fight(B *<a href="#Solution">Solution</a>) (A_wins <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Fight implements the competition between A and B
</p>

				
				
				
			
				
				<h3 id="Solution.GetCopyResults">func (*Solution) <a href="https://github.com/cpmech/goga/blob/master//solution.go?s=4573:4637#L190">GetCopyResults</a></h3>
				<pre>func (o *<a href="#Solution">Solution</a>) GetCopyResults() (xFlt []<a href="/pkg/builtin/#float64">float64</a>, xInt []<a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
GetCopyResults returns a copy of results (x vectors)
</p>

				
				
				
			
				
				<h3 id="Solution.OvaDistance">func (*Solution) <a href="https://github.com/cpmech/goga/blob/master//solution.go?s=2565:2645#L93">OvaDistance</a></h3>
				<pre>func (A *<a href="#Solution">Solution</a>) OvaDistance(B *<a href="#Solution">Solution</a>, omin, omax []<a href="/pkg/builtin/#float64">float64</a>) (dist <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
OvaDistance computes (phenotype) distance between A and B
</p>

				
				
				
			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		<tr>
		<td><a href="..">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="data/">data</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="doc/">doc</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="examples/">examples</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
	</table>

	

</dl>
</div><!-- manual-nav -->
</div><!-- page -->
<div id="footer">
<br /><br />
<hr>
<pre class="copyright">
Copyright (c) 2015, Dorival Pedroso
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of goga nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

</pre><!-- copyright -->
</div><!-- footer -->
</body>
</html>
